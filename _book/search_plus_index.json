{"./":{"url":"./","title":"Web全栈目录","keywords":"","body":"gitbook 平时学习的笔记 powered by GitbookFile Modify: 2022-03-27 16:32:29 "},"book/vue/01-vue基础.html":{"url":"book/vue/01-vue基础.html","title":"一、Vue 基础","keywords":"","body":"模板语法 插值 使用“Mustache”语法 (双大括号) 的文本插值 指令 常用指令 v-text 文本插值，在数据未渲染时候不会展示出来（可以用作界面优化） v-once 只渲染一次的文本插值 v-bind 绑定属性 v-html 渲染 html v-for 循环（key指定唯一性，用于dom diff；比 v-if 优先级高，同时使用时候请嵌套使用） v-model 双向数据绑定（用在输入控件上，语法糖，相当于绑定了 value 值和实现了 @input 事件） v-if / v-show v-else / v-else-if ... 指令缩写 v-on 缩写 @ v-bind 缩写 : 修饰符 .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .capture - 添加事件侦听器时使用 capture 模式。 .sync 相当于 $emit(\"update:var\", params) .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。 .native - 监听组件根元素的原生事件。 .once - 只触发一次回调。 .left - (2.2.0) 只当点击鼠标左键时触发。 .right - (2.2.0) 只当点击鼠标右键时触发。 .middle - (2.2.0) 只当点击鼠标中键时触发。 .passive - (2.3.0) 以 { passive: true } 模式添加侦听器 样式绑定 class / style 绑定 对象写法 对象 key 为要绑定的类名 / 属性名，对象 value 表达式确定是否绑定 ，例子如下： v-bind:class=\"{active: var === val}\" v-bind:style=\"{backgroundColor: var === val ? 'red' : ''}\" 数组写法 直接应用一个 class 列表 v-bind:class=\"[activeClass, errorClass]\" 根据条件切换列表中的 class 三元表达式 v-bind:class=\"[isActive ? activeClass : '', errorClass]\" 数组中使用对象写法 v-bind:class=\"[{ active: isActive }, errorClass]\" 计算属性和侦听器 计算属性 特点 计算属性可以缓存，当数据未变化时候，不会执行 setter 属性 计算属性默认只有 getter 属性，不过在需要时候也可以设置 setter 属性 computed: { fullName: { // getter get: function () { return this.firstName + ' ' + this.lastName }, // setter set: function (newValue) { var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] } } } 侦听器 用法 函数写法 带选项写法，选项如下： immediate deep handler 应用场景 侦听路由变化 $route 生命周期 beforeCreate() created() 组件实例已创建，dom 未挂载 beforeMount() mounted() beforeUpdate() updated() beforeDestroy() destroy() 组件化 组件 props 选项 type、default、required 组件分类 有状态组件 funtional 组件（无状态组件） abstract 组件，无界面，某一功能 组件定义尽量无状态化，这样组件可以更加内聚 组件优化：is、keep-alive、异步组件 插槽 匿名插槽 具名插槽 作用域插槽 必会 API 盘点 Vue.set() / delete() vm.$set() / delete() vm.$on() / vm.$emit() 事件总线 Vue.prototype.$bus = new Vue() 组件或元素引用（ref 和 vm.$refs） 动画 transition 指定 name 动画样式格式 [name]-[enter/leave]-[status] 动画顺序 [name]-enter [name]-enter-active [name]-enter-to（可以不定义） [name]-leave（可以不定义） [name]-leave-active [name]-leave-to css 动画库（通过自定义过渡类名结合 css 动画库实现） 动画样式格式 [enter/leave]-[status]-class = \"className\" 只需要指定 active 时候的样式 js 动画钩子（指定 name，定义过渡动画） 钩子列表 @before-enter @enter @after-enter @enter-cancel @before-leave @leave @after-leave @leave-cancel 纯 js 方案（过渡动画交给第三方库去做） 列表过渡 transition-group 可复用性 过滤器 自定义指令 渲染函数 函数式组件 混入 插件 powered by GitbookFile Modify: 2022-03-28 00:02:36 "},"book/vue/02-vue全家桶.html":{"url":"book/vue/02-vue全家桶.html","title":"二、Vue 全家桶","keywords":"","body":"vue-cli vue-router vueX axios powered by GitbookFile Modify: 2022-03-28 00:04:03 "},"book/vue/03-vue组件化.html":{"url":"book/vue/03-vue组件化.html","title":"三、Vue 组件化","keywords":"","body":"powered by GitbookFile Modify: 2022-02-25 22:55:34 "},"book/vue/04-vue全家桶原理.html":{"url":"book/vue/04-vue全家桶原理.html","title":"四、Vue 全家桶原理","keywords":"","body":"powered by GitbookFile Modify: 2022-02-25 22:55:46 "},"book/vue/05-vue原理剖析.html":{"url":"book/vue/05-vue原理剖析.html","title":"五、Vue 原理剖析","keywords":"","body":"介绍 Vue 的响应式原理是核心是通过 ES5 的保护对象的 Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM 树上。 原理实现 vue 进行实例化过程： 通过 Observer 劫持所有的数据。 解析模板里面出现的指令，再把通过 Observer 劫持的数据 getter 一下进行赋值，初始化视图。 同时定义一个更新函数和 Watcher，将来数据变化的时候 Watcher 会调用更新函数。 定义Proxy 函数代理 $data，方便用户直接访问 data 里面的数据。 new Vue() 构造函数解析 进行 new Vue() 时候会传入一个 options 选项，保存选项。 拿出选项 data 数据，传递给 Observer 做数据相应化。 创建编译器，传递 $el / vm 参数 Observer 数据响应化 对传入数据进行判断，如果是引用类型值进行递归遍历取出值，在进行 defineReactive 处理 Compile 编译 拿到模板遍历子元素，根据不同情况做处理： 文本元素 编译文本 节点元素 遍历属性，根据属性作不同处理： v 开头 v-text 处理 textContent v-html 处理 innerHTML v-model 监听 input @ 开头 绑定 click 事件 Watcher 更新函数 Dep 依赖管理 powered by GitbookFile Modify: 2022-03-28 00:04:55 "},"book/vue/06-vue2源码剖析.html":{"url":"book/vue/06-vue2源码剖析.html","title":"六、Vue2 源码剖析","keywords":"","body":"源码结构分析 dist 输出目录 examples 案例 scripts 构建脚本 src 源码 compiler 编译器相关 core 核心代码 components 通用组件如 keep-alive global-api 全局 api instance 构造函数 observer 响应式相关 utils vdom 虚拟 dom 相关 platforms 平台代码 web weeks packages 核心代码之外的独立库 flow / types 类型声明文件 术语解释： runtime 运行时环境，不带编译器，不能用 template common ejs 规范，用于 webpack1 esm ES Module 规范，用于 webpack2+ umd universal module definition，兼容 esj、esm规范，用于浏览器端 vue 初始化流程 入口文件 通过 package.json 启动命令找到入口文件 'src/platforms/web/entry-runtime-width-compiler.js' 在原型上复制一份 mount 方法；覆盖、扩展 $mount 方法 拿出 $options，进行模板解析 判断是否有 render，否则去看是否有 template，最后都没有看有没有 el 得到模板，执行编译（目的是拿到渲染函数） 在原始的 mount 方法上执行挂载函数 总结：重写 $mount 方法，进行模板解析，执行编译、挂载。 定义 $mount 在入口文件上找到引入 vue 文件 './runtime/vue' 指定了补丁__patch__方法（将传入的虚拟dom转为真实dom） 实现了 $mount 方法，执行 mountComponent()，将首次渲染结果替换 el 总结：定义 $mount src/core/index 在 './runtime/vue' 中找到定义 vue 文件 'core/index' => 'src/core/index' 定义全局 api（initGlobalAPI） 构造函数 在 'src/core/index' 中找到定义 vue文件 'src/core/instance/index' 执行初始化方法 _init(options) 定义实例方法 initMixin(Vue) 给 vue 原型添加 _init() 方法 stateMixin(Vue) $set、$delete、$watch eventsMixin(Vue) $emit、$on、$once、$off lifecycleMixin(Vue) _update()、$forceUpdate()、$destory renderMixin(Vue) _render()、$nextTick 通过 initMixin() 方法在 vue 原型上混入 _init() 方法 => 'src/core/instance/init.js' 合并 vue 默认 options 与传入 options initLifeCycle(vm) 初始化生命周期 建立组件联系，$parent、$root、$children 组件创建顺序（自上而下） 组件挂载顺序（自下而上） initEvents(vm) 对父组件传递的事件添加监听（事件谁派发谁监听） initRender(vm) 初始化插槽 初始化 h / $createElement 函数 callHook(vm, 'beforeCreate') 调用 beforeCreate 钩子 initInjections(vm) 注入数据 initState(vm) 数据初始化、数据响应式 initProvide(vm) 提供数据 callHook(vm, 'created') 调用 created 钩子 ​ 总结 vue 初始化流程 new Vue() => this._init(options) => $mount => mountComponent() => _render() => _update() new Vue() 调用 _init() 方法，初始化各种属性 调用 mountComponent() 声明 updateComponent() 创建 watcher（一个组件对应一个 watcher，更新时候调用 updateComponent） _render() 获取虚拟 dom _update() 将虚拟 dom 转为真实 dom vue 响应式原理 入口 在 src/core/instance/state.js 中 initData，获取 data 设置代理 启动响应式 (src/core/observer/index.js) 响应式入口 在 src/core/observer/index.js 中 observe() 尝试获取值是否有 ob，如果没有创建一个观察者实例，返回 ob Observer 类（每一个响应式对象都有一个 ob） def() 设置一个 __ob__ 属性，引用当前 Observer 实例 判断传入值类型 如果是数组，替换数组原型（替换数组原型 __proto__ 属性） 对象，执行 walk() 方法（循环对象所有的 key，执行 defineReactive()） 声明一个 dep，管理对象数组 object 中有新增删除属性 数组中有变更方法 defineReactive 属性拦截，只有是对象都会返回 childOb get 函数（依赖收集） ​ vue2 响应式缺点 递归遍历，性能受影响 api 不统一，数组和对象两套不同的处理 批量异步更新策略 利用 js 事件循环机制 事件循环：浏览器为了协调事件处理、脚本执行、网络请求和渲染任务而制定的一套工作机制 宏任务：代表一个离散的、独立的工作单元。浏览器完成一个宏任务，在下一个宏任务开始前，会对页面进行重新渲染。主要包括创建文档对象、解析 HTML、执行主线 JS 代码以及各种事件如页面加载、输入、网络事件和定时器等。 微任务：微任务是更小的任务，是在当前宏任务执行结束后立即执行的任务。如果存在微任务，浏览器会清空微任务之后在重新渲染。微任务的例子有 Promise 回调函数、Dom 发生变化。 虚拟 DOM powered by GitbookFile Modify: 2022-03-28 00:06:09 "},"book/vue/07-vue最佳实践.html":{"url":"book/vue/07-vue最佳实践.html","title":"七、Vue 最佳实践","keywords":"","body":"powered by GitbookFile Modify: 2022-02-25 23:05:42 "},"book/vue/08-vue服务端渲染.html":{"url":"book/vue/08-vue服务端渲染.html","title":"八、Vue 服务端渲染","keywords":"","body":"powered by GitbookFile Modify: 2022-02-25 22:57:47 "},"book/react/01-react基础.html":{"url":"book/react/01-react基础.html","title":"一、React 基础","keywords":"","body":"初识 React 创建 CRA 项目 // 全局安装 CRA 脚手架 yarn add create-react-app global npx create-react-app my-app template --typescript react 作用： 负责逻辑控制、数据 生成 virtual-dom react-dom 作用： 将 virtual-dom 转换成真实 dom JSX 语法 import React, { Component } from 'react'; const name = 'react'; const add = (a, b) => a + b; const jsxObj = jsxObj; const flag = true; const arr = [1, 2, 3]; class Jsx extends Component { render() { return {/* 1. 基本使用，变量用 {} 包裹 */} hello, {name} {/* 2. 函数，直接调用，有返回值 */} {add(1, 3)} {/* 3. jsx 对象 */} {jsxObj} {/* 4. 条件语句 */} {flag && jsxObj} {/* 5. 数组 */} { arr.map(item => ( /** * diff 的时候 * 1. 首先比较 type * 2. 然后是 key，所有同级同类型的元素，key值必须得唯一 * {item} )) } {/* 6. 属性 */} attr ; } } export default Jsx; 两种组件 class组件 拥有状态 拥有生命周期函数 function 组件 组件状态使用 useState 依赖项为空，表示只执行一次 有依赖，表示依赖变化执行里面的 setState 的用法 合成事件、生命周期中是异步的（批量更新、优化性能的目的） componentDidMount() { this.setState({ counter: this.state.counter + 1 }) } setCounter = () => { this.setState({ counter: this.state.counter + 1 }) }; render() { return { {this.state.counter} } } 在 setTimeout 中是同步的： setCounter = () => { setTimeout(() => { this.setState({ counter: this.state.counter + 1 }) }, 0) }; render() { return { {this.state.counter} } } 在原生事件中是同步的： componentDidMount() { document.querySelector('#app').addEventListener('click', () => { this.setCounter(); }) } setCounter = () => { this.setState({ counter: this.state.counter + 1 }) }; render() { return { {this.state.counter} } } setState 第二个参数为回调函数的时候是同步的： setCounter = () => { this.setState({ counter: this.state.counter + 1 }, () => { console.log(this.state.counter) }) }; render() { return { {this.state.counter} } } state 更新会被合并： 一个操作，对一个 state 进行多次更新，会被合并更新，同一个属性按照后面的 setCounter = () => { this.setState({ counter: this.state.counter + 1 }) this.setState({ counter: this.state.counter + 2 }) }; render() { return { {this.state.counter} } } 在这种情况下，想要实现链式更新，setState 第一个参数写成函数 setCounter = () => { this.setState(state => { return { counter: state.counter + 1 } }) this.setState(state => { return { counter: state.counter + 2 } }) }; render() { return { {this.state.counter} } } React 生命周期 v 16.3 之前的生命周期执行顺序 组件初始化： static defaultProps static propTypes constructor() componentWillMount() render() componentDidMount() 组件更新： willReceiveProps(nextProps) 接受父组件 props，初次渲染不执行 componentShouldUpdate() 更新 componentWillUpdate、render、componentDidMount() 一些生命周期被废除 废除 componentWillMount、componentWillReceiveProps、componentWillUpdate 如需使用添加 UNSAFE_ 前缀 使用命令批量添加 生命周期 componentWillReceiveProps(nextProps) 初次渲染时候不会执行，只有在已挂载的组件接受新的 props 的时候，才会执行 v16.4 之前要废除的生命周期用 getDerivedStateFromProps 代替，使用的话加上 UNSAFE_ UNSAFE_componentWillMount UNSAFE_componentWillReceiveProps UNSAFE_componentWillUpdate 如果不想要手动加前缀，采用命令方式 npx react-codemod rename-unsafe-lifecycles v16.4 及之后引入两个新生命周期 static getDerivedStateFromProps(props, state) 这个生命周期可以更新 state getSnapshotBeforeUpdate(prevProps, prevState) 这个生命周期可以将返回值传递给 componentDidUpdate(prevProps, prevState, snapShot) v16.4 生命周期执行顺序 组件初始化： static defaultProps static propTypes constructor() static getDerivedStateFromProps(props, state) render() componentDidMount() 组件更新： static getDerivedStateFromProps(props, state) shouldCompoentUpdate(nextProps,nextState)返回布尔确认是否更新 render() getSnapshotBeforeUpdate(prevProps,prevState)第一次没值 componentDidMount() Redux 使用场景： 大量、随时间变化的数据 state 需要有一个单一可靠的数据来源 state 放在最顶层组件中已经无法满足需要了 某个组件的状态需要共享 redux 更新流程： 视图需要更新，调用 redux 的 dispatch 方法并指定派发动作通知 Reducer Reducer 拿到当前 state 与 dispath 方法派发的动作，返回一个 newState store 中数据发生变化，通过subscribe()方法变更订阅通知页面更新 安装依赖 npm i redux -S 定义 store 存储数据（ redux 中导出 createStore 方法） 定义 reducer （定义state初始化修改规则） import { createStore } from 'redux'; function counterReducer(state = 0, action) { console.log('state',); switch (action.type) { case \"ADD\": return state + 1; case \"MINUNS\": return state - 1; default: return state; } } const store = createStore(counterReducer); export default store; store.getState() 获取状态 store.dispatch() 传递action 更新状态、 store.subscribe() 组件渲染完毕后调用，并在回调中调用 forceUpdate 方法强制刷新 import React, { Component } from 'react'; import store from '../store/index'; // 视图需要更新，调用 redux 的 dispatch 方法并指定派发动作通知Reducer ，Reducer 拿到当前 state 与 dispath 方法派发的动作，返回一个 newState，store中数据发生变化，通过subscribe()方法变更订阅通知页面更新 class ReduxPage extends Component { componentDidMount() { store.subscribe(() => { this.forceUpdate(); }) } render() { return {store.getState()} store.dispatch({ type: 'ADD' })}>ADD ; } } export default ReduxPage; React-redux 更为便捷的 react 版本的状态管理。 Provide 为后代组件提供store（好处：后代页面不需要在引入store） connect 为组件通过数据和变更方法 高阶组件，第一个参数用于映射 state、dispatch to props 第二个参数接收当前组件 依赖安装 npm i react-redux -S 定义 reducer // store/index.ts import { createStore } from 'redux'; function counterReducer(state = 0, action) { console.log('state',); switch (action.type) { case \"ADD\": return state + 1; case \"MINUNS\": return state - 1; default: return state; } } const store = createStore(counterReducer); export default store; 页面应用 import React, { Component } from 'react'; import { connect } from 'react-redux'; export default connect( // mapStateToProps 把 state 映射到 props state => ({ num: state }), // mapDispathToProps 把 dispath 映射到 props { add: () => ({type: \"ADD\"}) } )(class ReactReduxPage extends Component { render() { // const { num, dispatch } = this.props; const { num, add } = this.props; return {num} add({ type: 'ADD' })}>ADD ; } }) React-router react-router 包含三个库，react-router、react-router-dom、react-router-native reatc-router 提供最基本的路由功能，react-router-dom、react-router-native 都依赖 reatc-router 所以安装的时候也会自动安装 npm i react-router-dom -S 基本使用 import React, { Component } from 'react'; import { BrowserRouter as Router, Route, Link, Switch } from 'react-router-dom'; class RouterPage extends Component { render() { return ( 首页 用户中心 // 三种渲染方式互斥，优先级 children > component > render // child 渲染与 location 无关，其他两种都与 location 有关 children} render={() => render} /> // 写在最后，并且搭配 switch 使用 ); } } class HomePage extends Component { render() { return 首页 } } class UserPage extends Component { render() { return 用户中心 } } class EmptyPage extends Component { render() { return 404 } } powered by GitbookFile Modify: 2022-03-28 00:07:36 "},"book/react/02-react组件化.html":{"url":"book/react/02-react组件化.html","title":"二、React 组件化","keywords":"","body":"组件复合技术 组件调用时候自定义标签内容 jsx --- 组件内 this.props.children 获取 jsx（匿名插槽） 对象 --- 组件内 this.props.children 获取的对象信息（具名插槽） 高阶组件 - HOC 接收一个组件，返回一个新组件 装饰器写法： 依赖安装 npm i -D @babel/plugin-proposal-decorators 配置 config-overrides.js const {addDecoratorsLegacy} = require('customize-cra'); module.exports = override( addDecoratorsLegacy() // 配置装饰器 ) 如果 vscode 有警告，vscode 设置如下 javascript.implicitProjectConfig.experimentalDecorators: true 表单组件的设计与实现： 表单的双向绑定 onchange 与 e.target.value antd 的 @Form.create({}) getFieldDecorator(attr, {rules; [rules]}, comp) 高阶函数实现 antd 表单功能 getFieldDecorator(attr, {rules; [rules]}, comp) getFieldsValue() getFieldValue() validateFields() 弹窗类组件实现（React v16.3） import { createPortal } from 'react-dom' 创建 node 节点，挂载在 body 下 createPortal (, node); componentWillUnmount 时候 移除 node 纯组件 使用 setState 方法，但是 state 没有改变的时候，在 shouldComponentUpdate 中进行判断 使用 PureComponent 不用再写 shouldComponentUpdate，已经实现了浅比较。 组件跨层级通信 - Context 使用场景 多个子孙组件使用顶层祖辈的 state 网站主题色 创建 context、provider // ./src/context/themeContext.ts export const ThemeContext = React.createContext({num : 0}); export const ThemeProvider = ThemeContext.Provider(); // 创建消费者 export const ThemeConsumer = ThemeContext.Consumer(); 注入数据 import { ThemeProvider } from './src/context/themeContext.ts'; class ParentComp extends Component { constructor(props) { super(props) this.state = { num: 1 } } render() { return } } class子孙组件使用数据 import { ThemeContext } from './src/context/themeContext.ts'; export default class ChildCom extends Component { static contextType = ThemeContext; render() { return {this.context.num} } } export default ChildCom; 函数组件使用数据 import { ThemeConsumer } from './src/context/themeContext.ts'; const ChildCom = () => { return ( { ctx => ( {ctx.num} ) } ) }; export default ChildCom; powered by GitbookFile Modify: 2022-03-28 00:08:20 "},"book/react/03-react-redux源码.html":{"url":"book/react/03-react-redux源码.html","title":"三、React-Redux 源码","keywords":"","body":"Reducer powered by GitbookFile Modify: 2022-03-28 00:08:25 "},"book/react/04-react虚拟dom.html":{"url":"book/react/04-react虚拟dom.html","title":"四、React 虚拟 Dom","keywords":"","body":"什么是 vdom 用 javascript 对象表示 dom 信息与结构，当状态变更时候，重新渲染这个 JavaScript 的对象结构，这个 JavaScript 对象称为 vom 为什么用 vdom 传统 dom 渲染流程（domTree、styleRules、renderTree）渲染出来的 dom 节点比较庞大 比较真实 dom 节点时候比较庞大，成本高 用 js 对象处理，通过 diff 算法对新旧 vom 之间比较差异，最小化执行dom操作，提高性能 jsx react 中使用 jsx 描述试图，通过 babel-loader 转译后变成 React.createElement() 形式，该函数讲生成的 vdom 来描述真实 dom，如果将来状态变化，vdom做出相应变化，在通过 diff 算法对比新老 dom 区别从而做出最终dom操作 使用 jsx 是为了更简单生成 vdom React.createElement() 创建虚拟dom React.Component() 实现自定义组件 ReactDOM.render() 渲染真实dom 初次调用时候替换容器节点dom元素 第二次调用会使用 dom 差分算法，进行高效更新 powered by GitbookFile Modify: 2022-03-28 00:08:40 "},"book/react/05-react-hook.html":{"url":"book/react/05-react-hook.html","title":"五、React hook","keywords":"","body":"1.UseEffect() 和 didmount、didupdate类似 第二个参数为依赖项，只有依赖项发生变化才会执行 return 清除副作用，类似于 willUnMount 2.自定义hook 命名以 use 开头 函数内部可以调用其他hook 3.hook使用规则 只能在函数最外层调用hook，不能在循环、条件判断或者子函数调用 函数组件中调用hook、或者在自定义hook中调用hook 4.UseMemo() 接收两个参数，一个函数，一个依赖项 依赖项改变时候才会重新计算，避免在每次渲染时候都进行高额开销计算 5.UseCallBack() 接收两个参数，一个函数，一个依赖项 依赖项改变时候才会重新计算，避免子组件重新渲染 powered by GitbookFile Modify: 2022-02-24 22:22:20 "},"book/react/06-cra项目搭建.html":{"url":"book/react/06-cra项目搭建.html","title":"六、React CRA 项目搭建","keywords":"","body":"项目初始化 使用 create-react-app 搭建项目 // 全局安装 cra yarn add create-react-app global // 创建 cra ts 项目 npx create-react-app web --template typescript 路由组件配置管理 使用 react-router-config 集中式配置 react 路由，拥有 vue 配置路由的体验 使用 react-loadable 对组件进行异步加载处理 使用 react-router-dom 管理单页路由的跳转 安装依赖 // 安装 react-router-config yarn add react-router-config --development // 安装对应的类型声明 yarn add @types/react-router-config --development // 安装 react-loadable yarn add react-loadable --development // 安装对应的类型声明 yarn add @types/react-loadable --development // 安装 react-router-dom yarn add react-router-dom --development // 安装对应的类型声明 yarn add @types/react-router-dom --development 在根组件 App.tsx 中注册路由 import React from 'react'; import { renderRoutes } from 'react-router-config'; import { HashRouter } from 'react-router-dom'; import routes from './routers/index'; const App = () => ( {renderRoutes(routes)} ); export default App; react-router-config 接收一份路由配置，在 src 下新建 routers 文件夹管理路由 // ./src/routes/index.ts import Loadable from 'react-loadable'; import { RouteConfig } from 'react-router-config'; // 自定义 loading 组件 import Loading from '../components/Loading'; const routes: RouteConfig[] = [ { path: '/', exact: true, component: Loadable({ loader: () => import('../pages/home'), loading: Loading, }), } ]; export default routes; 修改 webpack 配置 修改 webpack 配置有两种方案 npm run eject 不可逆，暴露 create-react-app webpack 配置 使用 react-app-rewired 和 customize-cra 安装依赖 yarn add customize-cra react-app-rewired --development 修改目录下 package.json 文件 { \"scripts\": { \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewird test --env=jsdom\", } } 在项目根目录下添加 config-overrides.js 文件，在该文件中配置 webpack powered by GitbookFile Modify: 2022-03-28 00:09:06 "},"book/nodejs/01-core.html":{"url":"book/nodejs/01-core.html","title":"一、Nodejs 核心","keywords":"","body":"node 特点 javascript 运行时环境（什么叫运行时） 非阻塞I/O（查资料） 事件驱动（查资料） 并发处理历史进程 多进程 c 多线程 java 异步IO js 协程 lua openresty go docker nodemon 工具 文件变化，自动重启，利于调试 vs code 中 nodejs debug 查资料了解 nodejs 第三方库 cpu-stat cpu状态 异步处理 promisity（了解） async/await powered by GitbookFile Modify: 2022-02-25 19:14:18 "},"book/nodejs/02-net.html":{"url":"book/nodejs/02-net.html","title":"二、Nodejs 网络通信","keywords":"","body":"网络通信 osi参考模型 物理层 数据链路层 网络层 传输层 会话层 表示层 应用层 tcp/ip模式 以太网、无线（1、2） 网络层（3） 传输层（4） 应用层（5、6、7） 通常是在传输层与应用层进行编程 HTTP 状态码 1xx：已经接收，继续处理 2xx：成功 3xx：重定向 4xx：客户端错误 5xx：服务器错误 了解常用的状态码 200、400、401、403、404、500、503 跨域 简单请求：get、post跨域（后端加入可允许访问源） 预检请求：put、delete等都有options类型请求，设置header nginx 反向代理（含义） 实战爬虫 cheerio iconv-lites request HTTP2 多路复用 服务器推送 首部压缩 了解 jsonrpc thrift preeflight request mactalk credential 请求 web uploader 工具 live-server process on 思维导图 swagger kibanna es 目标 使用 socket.io 编写一个聊天工具 看课件 实战爬虫 o-my-zsh + iterm powered by GitbookFile Modify: 2022-02-25 19:14:18 "},"book/nodejs/03-mongodb.html":{"url":"book/nodejs/03-mongodb.html","title":"三、Nodejs 数据持久化","keywords":"","body":"mongo 命令行 数据库操作： 查看所有数据库（为空的不显示）：show dbs 正在使用的数据库：db 切换数据库（不存在，则新建）：use 表操作： 查看表：db.collections 表插入： 新增一条数据：db.collection.insert(data) 新增多条数据：db.collection.insertMany([data1, data2, ...]); 表删除： 删除数据：db.collection.remove(condition) 表查询操作： 查看所有数据：db.collection.find() 相当于 db.collection.find({}) 可以增加第二个参数，自定义返回字段 db.collection.find({}, {key: 1, _id: 0}) id的默认为1，默认返回，0为不返回 按条件查询数据：db.collection.find(condition) collection 里面可以使用正则进行匹配 查询条件：db.find({key: {$gt: num, $lt: num}}) $gt $gte $lt $lte $ne != $in $nin（在一个字段中查找） $or（可以是多个字段） $type Double 1 String 2 Object 3 Array 4 Boolean 8 Date 9 Null 10 REGEXP 11 以上常用、其他不列举了... $not $and 表更新操作 更新数据（只会更新满足条件的第一个，一条数据的所有字段）：db.collection.update(condition, newVal); 更新多条数据中的一个字段：db.collection.update(condition, {$set: newVal}, false, true) 第三个参数代表，如果未查询到更新数据，是否插入一条，默认false，不插入 第四个参数代表，查询到更新数据之后，是否更新多条 增加已有键的值，如果没有则新建（更新满足条件的第一个）：db.collection.update(condition, {$inc: newVal}) 向已有数组尾部追加一个元素，如果没有就创建新数组：db.collection.update(condition, {$push: newVal}) 向已有数组尾部追加多个元素：db.collection.update(condition, {$push: {newValKey: {$each: newValArray}}}) slice 固定数组长度，不足则添加，多了则会保存最新的固定长度：db.collection.update(condition, {$push: {newValKey: {$each: newValArray, $slice: fixNum}}}) fixNum 为负数，当元素溢出的时候，保存最新的 fixNum 为整数，当元素溢出的时候，保存最先添加进去的 向数组添加一个元素，如果数组不存在则创建，添加元素不存在则添加，否则，不添加：db.collection.update(condition, {$addToSet: newVal}) 向数组添加多个元素，如果数组不存在则创建，添加元素不存在则添加，否则，不添加：db.collection.update(condition, {$addToSet: {$each: [newVal1, newVal2, ...]}}) 删除数组中一个元素：db.connection.update(condition, {$pop: key: num}) num 为 1 则表示从尾部删除， -1 表示从头部删除 按条件删除数组中的元素（可以是多个）：db.connection.update(condition, {$pull: newVal}) 访问数组下标 array.0（数组第0个元素） db.collection({a: 1}, {$set: {a.$: 2}}) ​$表示当前满足条件的索引 save 接受一个参数，这个参数就是文档，当文档里面有 _id 参数则表示更新，否则为插入操作 powered by GitbookFile Modify: 2022-03-26 18:07:28 "},"book/nodejs/04-koa.html":{"url":"book/nodejs/04-koa.html","title":"四、Nodejs koa 框架","keywords":"","body":"context 对象 req res request response state app 中间件 顺序执行的需要 切面描述的需要，横向（鉴权、错误处理、日志） AOP 编程 语言级 - java 框架级 常用中间件 错误中间件（提交代码健壮性） 中间件错误 try/catch 应用级错误 error 事件 严重错误 抛错 Hash 算法（SHA MD5） 含义 将一个不定长的摘要定长结果 满足条件 摘要（不可逆，防串改） 雪崩效应（密文微小变化，明文剧烈变化） 后端算法 摘要 对称 DES 非对称 RSA koa 鉴权 Session/Cookie cookie 约定头，Set-Cookie 相关方法 取值 cookie req.headers.cookie 设置 res.setHeader('Set-Cookie', 'username=a') 缺点 js 可以直接读取，不安全 cookie 太小 cookie 同源策略 优化方式 通过 cookie session 模式，后端存储键值对的key在前端，键值存储在后端，解决了安全和大小 通过 redis 全局化 session（解决多台node服务器cookie不同源） axios 中配置 中请求拦截器中设置 config.headers.common[\"Authorization\"] = \"Bearer \" + token; Token token 放在header，遵循 jwt 约定 config.headers.common['Authorization'] = \"Bearer \" + token; token 组成 第一部分令牌头，base64 编码 第二部分payload，base64 编码 第三部分hash，对前面部分进行签名 OAuth（开放授权） github - 授权码登录 发出授权请求，通过 302 到第三方授权（需要client id） 成功之后，通过 302 到自己的服务器设置的 callback 请求（callback 之后返回 code） callback 请求之后，通过 gettoken 获取真正的 token（gettoken 换取 token 需要 id、密码、code） 通过 token 请求 user 接口，得到个人信息 restful linux 公钥信任 linux 命令 查看 cat tail vi powered by GitbookFile Modify: 2022-03-11 03:41:33 "},"book/nodejs/05-egg.html":{"url":"book/nodejs/05-egg.html","title":"五、Nodejs egg 框架","keywords":"","body":"后端的三层模式 界面层 接收数据请求，返回数据结果及界面效果展示 别名：表现层、外观层 业务逻辑层 对数据业务需求逻辑进行实现处理 别名：领域层 数据访问层 增删改查 别名：持久层 MVC 模式 egg 分层 路由 控制器 restful 页面请求 代理服务器 服务 数据层 mongoose sequelize powered by GitbookFile Modify: 2022-02-25 19:14:18 "},"book/nodejs/06-deploy.html":{"url":"book/nodejs/06-deploy.html","title":"六、Nodejs 部署","keywords":"","body":"构建一个高可用的 node 环境 故障恢复 充分多核资源的利用 多进程共享端口 cluster 模块 fork 模式 nodejs 中实现端口重用的原理 文件上传服务器 scp git deploy插件 pm2 内建负载均衡 线程守护 0秒停机重载 docker命令 简单启动：docker run -p 80:80 -v $PWD/www:/user/share/nginx/html -d nginx 查看进程：docker ps 停止进程：docker stop pid 删除镜像：docker rm pid 拉取镜像：docker pull nginx 查看镜像：docker image nginx 制作镜像：docker build -t myimage . 启动定制镜像：docker run -p 80:80 -d myimage Dockerfile 文件 Docker-Compose 启动：docker-compose up -d --force-recreate --build 关闭：docker-compose down Docker/Github Webhook实现CI的持续集成 powered by GitbookFile Modify: 2022-03-26 22:37:06 "}}