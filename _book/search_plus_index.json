{"./":{"url":"./","title":"目录说明","keywords":"","body":"powered by GitbookFile Modify: 2024-10-31 10:47:47 "},"RULE.html":{"url":"RULE.html","title":"写作规范","keywords":"","body":"powered by GitbookFile Modify: 2024-10-31 10:47:42 "},"book/web/vue/":{"url":"book/web/vue/","title":"Vue","keywords":"","body":"powered by GitbookFile Modify: 2024-10-30 18:45:45 "},"book/web/vue/01-vue基础.html":{"url":"book/web/vue/01-vue基础.html","title":"一、Vue 基础","keywords":"","body":"一、模板语法 1、插值 使用“Mustache”语法 (双大括号) 的文本插值 二、指令 1、常用指令 v-text 文本插值，在数据未渲染时候不会展示出来（可以用作界面优化） v-once 只渲染一次的文本插值 v-bind 绑定属性 v-html 渲染 html v-for 循环（key指定唯一性，用于dom diff；比 v-if 优先级高，同时使用时候请嵌套使用） v-model 双向数据绑定（用在输入控件上，语法糖，相当于绑定了 value 值和实现了 @input 事件） v-if / v-show v-else / v-else-if ... 2、指令缩写 v-on 缩写 @ v-bind 缩写 : 3、指令修饰符 .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .capture - 添加事件侦听器时使用 capture 模式。 .sync 相当于 $emit(\"update:var\", params) .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。 .native - 监听组件根元素的原生事件。 .once - 只触发一次回调。 .left - (2.2.0) 只当点击鼠标左键时触发。 .right - (2.2.0) 只当点击鼠标右键时触发。 .middle - (2.2.0) 只当点击鼠标中键时触发。 .passive - (2.3.0) 以 { passive: true } 模式添加侦听器 三、样式绑定 1、class / style 绑定 1）对象写法 对象 key 为要绑定的类名 / 属性名，对象 value 表达式确定是否绑定 ，例子如下： v-bind:class=\"{active: var === val}\" v-bind:style=\"{backgroundColor: var === val ? 'red' : ''}\" 2）数组写法 直接应用一个 class 列表 v-bind:class=\"[activeClass, errorClass]\" 根据条件切换列表中的 class 三元表达式 v-bind:class=\"[isActive ? activeClass : '', errorClass]\" 数组中使用对象写法 v-bind:class=\"[{ active: isActive }, errorClass]\" 四、计算属性和侦听器 1、计算属性 1）特点 计算属性可以缓存，当数据未变化时候，不会执行 2）setter 属性 计算属性默认只有 getter 属性，不过在需要时候也可以设置 setter 属性 computed: { fullName: { // getter get: function () { return this.firstName + ' ' + this.lastName }, // setter set: function (newValue) { var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] } } } 五、侦听器 1、用法 函数写法 带选项写法，选项如下： immediate deep handler 2、应用场景 侦听路由变化 $route 六、生命周期 1、beforeCreate() 2、created() 组件实例已创建，dom 未挂载 3、beforeMount() 4、mounted() 5、beforeUpdate() 6、updated() 7、beforeDestroy() 8、destroy() 七、组件化 1、组件 props 选项 1）type 2）default 3）required 2、组件分类 1）有状态组件 2）funtional 组件（无状态组件） 3）abstract 组件，无界面，某一功能 3、组件定义尽量无状态化，这样组件可以更加内聚 4、组件优化：is、keep-alive、异步组件 5、插槽 1）匿名插槽 2）具名插槽 3）作用域插槽 八、必会 API 盘点 1、Vue.set() / delete() vm.$set() / delete() 2、vm.$on() / vm.$emit() 3、事件总线 Vue.prototype.$bus = new Vue() 4、组件或元素引用（ref 和 vm.$refs） 九、动画 transition 1、指定 name 1）动画样式格式 [name]-[enter/leave]-[status] 2）动画顺序 [name]-enter [name]-enter-active [name]-enter-to（可以不定义） [name]-leave（可以不定义） [name]-leave-active [name]-leave-to 2、css 动画库（通过自定义过渡类名结合 css 动画库实现） 动画样式格式 [enter/leave]-[status]-class = \"className\" 只需要指定 active 时候的样式 3、js 动画钩子（指定 name，定义过渡动画） 1）钩子列表 @before-enter @enter @after-enter @enter-cancel @before-leave @leave @after-leave @leave-cancel 4、纯 js 方案（过渡动画交给第三方库去做） 5、列表过渡 transition-group 十、可复用性 1、过滤器 2、自定义指令 3、渲染函数 4、函数式组件 5、混入 6、插件 powered by GitbookFile Modify: 2024-10-30 17:49:34 "},"book/web/vue/02-vue全家桶.html":{"url":"book/web/vue/02-vue全家桶.html","title":"二、Vue 全家桶","keywords":"","body":"一、vue-cli 二、vue-router 三、vueX 四、axios powered by GitbookFile Modify: 2024-10-30 17:50:45 "},"book/web/vue/03-vue组件化.html":{"url":"book/web/vue/03-vue组件化.html","title":"三、Vue 组件化","keywords":"","body":"powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/vue/04-vue全家桶原理.html":{"url":"book/web/vue/04-vue全家桶原理.html","title":"四、Vue 全家桶原理","keywords":"","body":"powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/vue/05-vue原理剖析.html":{"url":"book/web/vue/05-vue原理剖析.html","title":"五、Vue 原理剖析","keywords":"","body":"一、介绍 Vue 的响应式原理是核心是通过 ES5 的保护对象的 Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM 树上。 二、原理实现 1、vue 进行实例化过程： 通过 Observer 劫持所有的数据。 解析模板里面出现的指令，再把通过 Observer 劫持的数据 getter 一下进行赋值，初始化视图。 同时定义一个更新函数和 Watcher，将来数据变化的时候 Watcher 会调用更新函数。 定义Proxy 函数代理 $data，方便用户直接访问 data 里面的数据。 2、new Vue() 构造函数解析 进行 new Vue() 时候会传入一个 options 选项，保存选项。 拿出选项 data 数据，传递给 Observer 做数据相应化。 创建编译器，传递 $el / vm 参数 3、Observer 数据响应化 对传入数据进行判断，如果是引用类型值进行递归遍历取出值，在进行 defineReactive 处理 三、Compile 编译 拿到模板遍历子元素，根据不同情况做处理： 1、文本元素 编译文本 2、节点元素 遍历属性，根据属性作不同处理： v 开头 v-text 处理 textContent v-html 处理 innerHTML v-model 监听 input @ 开头 绑定 click 事件 四、Watcher 更新函数 五、Dep 依赖管理 powered by GitbookFile Modify: 2024-10-30 17:53:02 "},"book/web/vue/06-vue2源码剖析.html":{"url":"book/web/vue/06-vue2源码剖析.html","title":"六、Vue2 源码剖析","keywords":"","body":"一、源码结构分析 dist 输出目录 examples 案例 scripts 构建脚本 src 源码 compiler 编译器相关 core 核心代码 components 通用组件如 keep-alive global-api 全局 api instance 构造函数 observer 响应式相关 utils vdom 虚拟 dom 相关 platforms 平台代码 web weeks packages 核心代码之外的独立库 flow / types 类型声明文件 术语解释： runtime 运行时环境，不带编译器，不能用 template common ejs 规范，用于 webpack1 esm ES Module 规范，用于 webpack2+ umd universal module definition，兼容 esj、esm规范，用于浏览器端 二、vue 初始化流程 1、入口文件 通过 package.json 启动命令找到入口文件 'src/platforms/web/entry-runtime-width-compiler.js' 在原型上复制一份 mount 方法；覆盖、扩展 $mount 方法 拿出 $options，进行模板解析 判断是否有 render，否则去看是否有 template，最后都没有看有没有 el 得到模板，执行编译（目的是拿到渲染函数） 在原始的 mount 方法上执行挂载函数 总结：重写 $mount 方法，进行模板解析，执行编译、挂载。 2、定义 $mount 在入口文件上找到引入 vue 文件 './runtime/vue' 指定了补丁__patch__方法（将传入的虚拟dom转为真实dom） 实现了 $mount 方法，执行 mountComponent()，将首次渲染结果替换 el 总结：定义 $mount 3、src/core/index 在 './runtime/vue' 中找到定义 vue 文件 'core/index' => 'src/core/index' 定义全局 api（initGlobalAPI） 4、构造函数 在 'src/core/index' 中找到定义 vue文件 'src/core/instance/index' 执行初始化方法 _init(options) 定义实例方法 initMixin(Vue) 给 vue 原型添加 _init() 方法 stateMixin(Vue) $set、$delete、$watch eventsMixin(Vue) $emit、$on、$once、$off lifecycleMixin(Vue) _update()、$forceUpdate()、$destory renderMixin(Vue) _render()、$nextTick 通过 initMixin() 方法在 vue 原型上混入 _init() 方法 => 'src/core/instance/init.js' 合并 vue 默认 options 与传入 options initLifeCycle(vm) 初始化生命周期 建立组件联系，$parent、$root、$children 组件创建顺序（自上而下） 组件挂载顺序（自下而上） initEvents(vm) 对父组件传递的事件添加监听（事件谁派发谁监听） initRender(vm) 初始化插槽 初始化 h / $createElement 函数 callHook(vm, 'beforeCreate') 调用 beforeCreate 钩子 initInjections(vm) 注入数据 initState(vm) 数据初始化、数据响应式 initProvide(vm) 提供数据 callHook(vm, 'created') 调用 created 钩子 三、总结 vue 初始化流程 new Vue() => this._init(options) => $mount => mountComponent() => _render() => _update() new Vue() 调用 _init() 方法，初始化各种属性 调用 mountComponent() 声明 updateComponent() 创建 watcher（一个组件对应一个 watcher，更新时候调用 updateComponent） _render() 获取虚拟 dom _update() 将虚拟 dom 转为真实 dom 四、vue 响应式原理 1、入口 在 src/core/instance/state.js 中 initData，获取 data 设置代理 启动响应式 (src/core/observer/index.js) 2、响应式入口 在 src/core/observer/index.js 中 observe() 尝试获取值是否有 ob，如果没有创建一个观察者实例，返回 ob Observer 类（每一个响应式对象都有一个 ob） def() 设置一个 __ob__ 属性，引用当前 Observer 实例 判断传入值类型 如果是数组，替换数组原型（替换数组原型 __proto__ 属性） 对象，执行 walk() 方法（循环对象所有的 key，执行 defineReactive()） 声明一个 dep，管理对象数组 object 中有新增删除属性 数组中有变更方法 defineReactive 属性拦截，只有是对象都会返回 childOb get 函数（依赖收集） 3、vue2 响应式缺点 递归遍历，性能受影响 api 不统一，数组和对象两套不同的处理 四、批量异步更新策略 五、利用 js 事件循环机制 事件循环：浏览器为了协调事件处理、脚本执行、网络请求和渲染任务而制定的一套工作机制 宏任务：代表一个离散的、独立的工作单元。浏览器完成一个宏任务，在下一个宏任务开始前，会对页面进行重新渲染。主要包括创建文档对象、解析 HTML、执行主线 JS 代码以及各种事件如页面加载、输入、网络事件和定时器等。 微任务：微任务是更小的任务，是在当前宏任务执行结束后立即执行的任务。如果存在微任务，浏览器会清空微任务之后在重新渲染。微任务的例子有 Promise 回调函数、Dom 发生变化。 六、虚拟 DOM powered by GitbookFile Modify: 2024-10-30 17:55:25 "},"book/web/vue/07-vue最佳实践.html":{"url":"book/web/vue/07-vue最佳实践.html","title":"七、Vue 最佳实践","keywords":"","body":"powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/vue/08-vue服务端渲染.html":{"url":"book/web/vue/08-vue服务端渲染.html","title":"八、Vue 服务端渲染","keywords":"","body":"powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/react/":{"url":"book/web/react/","title":"React","keywords":"","body":" cra 使用 安装 暴露配置 jsx语法 class组件与function组件 setstate 用法 新旧生命周期 redux react-react context api react-router 组件复合 高阶组件 纯组件 hook powered by GitbookFile Modify: 2024-10-30 22:02:49 "},"book/web/react/01-react基础.html":{"url":"book/web/react/01-react基础.html","title":"一、React 基础","keywords":"","body":"一、react、react-dom作用 1、react 负责描述特性，提供React API 类组件、函数组件、hooks、contexts、refs...这些都是React特性，而 react 模块只描述特性长什么样、该怎么用，并不负责特性的具体实现。 2、react-dom 作用 react-dom称为渲染器，负责在不同的宿主载体上实现特性，达到与描述相对应的真实效果。比如渲染出DOM树、响应点击事件等。 二、JSX 语法 1、基本使用，变量用 {} 包裹 hello, { name } 2、有返回值的函数直接调用，用 {} 包裹 { add(1, 3) } 3、html标签，用 {} 包裹 { hello } 4、条件语句，用 {} 包裹 { Bolean(true) && hello } 5、数组循环输出，用 {} 包裹 { arr.map(item => ({ item })) } 6、作为属性值，用 {} 包裹 三、两种组件 1、class组件 （1）拥有状态 （2）拥有生命周期函数 2、function 组件 （1）组件状态使用 useState 依赖项为空，表示只执行一次 有依赖，表示依赖变化执行里面的 四、setState 的用法 1、合成事件、生命周期中是异步的（批量更新、优化性能的目的） componentDidMount() { this.setState({ counter: this.state.counter + 1 }) } { groupName: \"\", groupMember: \"\", } setCounter = () => { this.setState({ counter: this.state.counter + 1 }) }; render() { return { {this.state.counter} } } 2、在 setTimeout / 原生事件 / setState第二个回调参数中 访问是同步的： setTimeout setCounter = () => { setTimeout(() => { this.setState({ counter: this.state.counter + 1 }) }, 0) }; render() { return { {this.state.counter} } } 在原生事件中是同步的， componentDidMount() { document.querySelector('#app').addEventListener('click', () => { this.setCounter(); }) } setCounter = () => { this.setState({ counter: this.state.counter + 1 }) }; render() { return { {this.state.counter} } } setState 第二个参数为回调函数的时候是同步的： setCounter = () => { this.setState({ counter: this.state.counter + 1 }, () => { console.log(this.state.counter) }) }; render() { return { {this.state.counter} } } 3、state 更新会被合并： （1）一个操作，对一个 state 进行多次更新，会被合并更新，同一个属性按照后面的 setCounter = () => { this.setState({ counter: this.state.counter + 1 }) this.setState({ counter: this.state.counter + 2 }) }; render() { return { {this.state.counter} } } （2）在这种情况下，想要实现链式更新，setState 第一个参数写成函数 setCounter = () => { this.setState(state => { return { counter: state.counter + 1 } }) this.setState(state => { return { counter: state.counter + 2 } }) }; render() { return { {this.state.counter} } } 五、React 生命周期 1、v 16.3 之前的生命周期执行顺序 （1）组件初始化流程 static defaultProps 默认属性 static propTypes propTypes.string.isRequired constructor() componentWillMount() render() componentDidMount() （2）组件更新流程 willReceiveProps(nextProps) 接受父组件 props，初次渲染不执行，可以用这个做性能优化 componentShouldUpdate() 更新 componentWillUpdate、render、componentDidUpdate() 2、一些生命周期被废除 （1）废除 componentWillMount、componentWillReceiveProps、componentWillUpdate （2）componentWillReceiveProps(nextProps) 初次渲染时候不会执行只有在已挂载的组件接受新的 props 的时候，才会执行 （3）如需使用添加 UNSAFE_ 前缀 UNSAFE_componentWillMount UNSAFE_componentWillReceiveProps UNSAFE_componentWillUpdate 也可以使用命令批量添加 npx react-codemod rename-unsafe-lifecycles 3、v16.4 及之后引入两个新生命周期 （1）static getDerivedStateFromProps(props, state) 这个生命周期可以更新 state （2）getSnapshotBeforeUpdate(prevProps, prevState) 在更新之前的缩影 这个生命周期可以将返回值传递给 componentDidUpdate(prevProps, prevState, snapShot) 4、v16.4 生命周期执行顺序 （1）组件初始化： static defaultProps static propTypes constructor() static getDerivedStateFromProps(props, state) render() componentDidMount() （2）组件更新： static getDerivedStateFromProps(props, state) shouldCompoentUpdate(nextProps,nextState)返回布尔确认是否更新 render() getSnapshotBeforeUpdate(prevProps,prevState)第一次没值 componentDidMount(nextProps,nextState, snap) 六、Redux 1、安装依赖 npm i redux -S 2、使用场景： （1）大量、随时间变化的数据 （2）state 需要有一个单一可靠的数据来源 （3）state 放在最顶层组件中已经无法满足需要了 （4）某个组件的状态需要共享 3、redux 更新流程： （1）视图需要更新，调用 redux 的 dispatch 方法并指定派发动作通知 Reducer （2）Reducer 拿到当前 state 与 dispath 方法派发的动作，返回一个 newState （3）store 中数据发生变化，通过subscribe()方法变更订阅通知页面更新 4、具体实现 （1）定义 store 存储数据（ redux 中导出 createStore 方法） （2）定义 reducer （定义state初始化修改规则） import { createStore } from 'redux'; function counterReducer(state = 0, action) { console.log('state',); switch (action.type) { case \"ADD\": return state + 1; case \"MINUNS\": return state - 1; default: return state; } } const store = createStore(counterReducer); export default store; （3）store.getState() 获取状态 （4）store.dispatch() 传递action 更新状态、 （5）store.subscribe() 组件渲染完毕后调用，并在回调中调用 forceUpdate 方法强制刷新 import React, { Component } from 'react'; import store from '../store/index'; // 视图需要更新，调用 redux 的 dispatch 方法并指定派发动作通知Reducer ，Reducer 拿到当前 state 与 dispath 方法派发的动作，返回一个 newState，store中数据发生变化，通过subscribe()方法变更订阅通知页面更新 class ReduxPage extends Component { componentDidMount() { store.subscribe(() => { this.forceUpdate(); }) } render() { return {store.getState()} store.dispatch({ type: 'ADD' })}>ADD ; } } export default ReduxPage; 七、React-redux 1、依赖安装 npm i react-redux -S 2、更为便捷的 react 版本的状态管理。 （1）Provide 为后代组件提供store（好处：后代页面不需要在引入store） （2）connect 为组件通过数据和变更方法 高阶组件，第一个参数用于映射 state、dispatch to props 第二个参数接收当前组件 3、使用reducer （1）定义reducer // store/index.ts import { createStore } from 'redux'; function counterReducer(state = 0, action) { console.log('state',); switch (action.type) { case \"ADD\": return state + 1; case \"MINUNS\": return state - 1; default: return state; } } const store = createStore(counterReducer); export default store; （2）页面应用 import React, { Component } from 'react'; import { connect } from 'react-redux'; export default connect( // mapStateToProps 把 state 映射到 props state => ({ num: state }), // mapDispathToProps 把 dispath 映射到 props { add: () => ({type: \"ADD\"}) } )(class ReactReduxPage extends Component { render() { // const { num, dispatch } = this.props; const { num, add } = this.props; return {num} add({ type: 'ADD' })}>ADD ; } }) 八、React-router 1、安装 npm i react-router-dom -S 2、Raect-router 介绍 （1）reatc-router 提供最基本的路由功能 （2）react-router-dom 依赖 reatc-router 所以安装的时候也会自动安装 3、Route 匹配 location 与 component 的映射关系 （1）三种渲染方式互斥 优先级 children > component > render （2）children 渲染与 location 无关，其他两种都与location有关 （3）switch 独占路由，只会渲染一个 配合写在最后的Route组件并且没有path，实现404页面 import React, { Component } from 'react'; import { BrowserRouter as Router, Route, Link, Switch } from 'react-router-dom'; class RouterPage extends Component { render() { return ( // link 路由跳转 // Route 匹配location与component的映射关系 首页 用户中心 // 三种渲染方式互斥，优先级 children > component > render // children 渲染与 location 无关，其他两种都与 location 有关 children} render={() => render} /> // 写在最后，并且搭配 switch 使用 ); } } class HomePage extends Component { render() { return 首页 } } class UserPage extends Component { render() { return 用户中心 } } class EmptyPage extends Component { render() { return 404 } } powered by GitbookFile Modify: 2024-10-31 12:56:12 "},"book/web/react/02-react组件化.html":{"url":"book/web/react/02-react组件化.html","title":"二、React 组件化","keywords":"","body":"一、组件复合技术（插槽） 组件调用时候自定义标签内容（xxxxxxxx） jsx --- 组件内 this.props.children 获取 jsx（匿名插槽） 对象 --- 组件内 this.props.children 获取的对象信息（具名插槽） 二、高阶组件 - HOC 接收一个组件，返回一个新组件 装饰器写法： 依赖安装 npm i -D @babel/plugin-proposal-decorators 配置 config-overrides.js const {addDecoratorsLegacy} = require('customize-cra'); module.exports = override( addDecoratorsLegacy() // 配置装饰器 ) 如果 vscode 有警告，vscode 设置如下 javascript.implicitProjectConfig.experimentalDecorators: true 不要在 render() 函数中使用高阶组件 表单组件的设计与实现： 表单的双向绑定 onchange 与 e.target.value antd 的 @Form.create({}) getFieldDecorator(attr, {rules; [rules]}, comp) 高阶函数实现 antd 表单功能 getFieldDecorator(attr, {rules; [rules]}, comp) getFieldsValue() getFieldValue() validateFields() 弹窗类组件实现（React v16.3） import { createPortal } from 'react-dom' 创建 node 节点，挂载在 body 下 createPortal (, node); componentWillUnmount 时候 移除 node 三、纯组件 使用 setState 方法，但是 state 没有改变的时候，在 shouldComponentUpdate 中进行判断 使用 PureComponent 不用再写 shouldComponentUpdate，已经实现了浅比较。 React.memo() 四、组件跨层级通信 - Context 使用场景 多个子孙组件使用顶层祖辈的 state 网站主题色 创建 context、provider // ./src/context/themeContext.ts export const ThemeContext = React.createContext({num : 0}); export const ThemeProvider = ThemeContext.Provider(); // 创建消费者 export const ThemeConsumer = ThemeContext.Consumer(); 注入数据 import { ThemeProvider } from './src/context/themeContext.ts'; class ParentComp extends Component { constructor(props) { super(props) this.state = { num: 1 } } render() { return } } class子孙组件使用数据 import { ThemeContext } from './src/context/themeContext.ts'; export default class ChildCom extends Component { static contextType = ThemeContext; render() { return {this.context.num} } } export default ChildCom; 函数组件使用数据 import { ThemeConsumer } from './src/context/themeContext.ts'; const ChildCom = () => { return ( { ctx => ( {ctx.num} ) } ) }; export default ChildCom; 五、传送门 powered by GitbookFile Modify: 2024-10-31 12:03:04 "},"book/web/react/03-react-redux源码.html":{"url":"book/web/react/03-react-redux源码.html","title":"三、React-Redux 源码","keywords":"","body":"Reducer powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/react/04-react虚拟dom.html":{"url":"book/web/react/04-react虚拟dom.html","title":"四、React 虚拟 Dom","keywords":"","body":"什么是 vdom 用 javascript 对象表示 dom 信息与结构，当状态变更时候，重新渲染这个 JavaScript 的对象结构，这个 JavaScript 对象称为 vom 为什么用 vdom 传统 dom 渲染流程（domTree、styleRules、renderTree）渲染出来的 dom 节点比较庞大 比较真实 dom 节点时候比较庞大，成本高 用 js 对象处理，通过 diff 算法对新旧 vom 之间比较差异，最小化执行dom操作，提高性能 jsx react 中使用 jsx 描述试图，通过 babel-loader 转译后变成 React.createElement() 形式，该函数讲生成的 vdom 来描述真实 dom，如果将来状态变化，vdom做出相应变化，在通过 diff 算法对比新老 dom 区别从而做出最终dom操作 使用 jsx 是为了更简单生成 vdom React.createElement() 创建虚拟dom React.Component() 实现自定义组件 ReactDOM.render() 渲染真实dom 初次调用时候替换容器节点dom元素 第二次调用会使用 dom 差分算法，进行高效更新 powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/react/05-react-hook.html":{"url":"book/web/react/05-react-hook.html","title":"五、React hook","keywords":"","body":"一、常用hook 1、UseEffect() 和 didmount、didupdate类似 第二个参数为依赖项，只有依赖项发生变化才会执行 return 清除副作用，类似于 willUnMount 2、UseMemo() 相当于computed，缓存计算值 接收两个参数，一个函数，一个依赖项 依赖项改变时候才会重新计算，避免在每次渲染时候都进行高额开销计算 3、UseCallBack() 相当于纯函数，但是纯函数比较的是值，这里是函数 接收两个参数，一个函数，一个依赖项 依赖项改变时候才会重新计算，避免子组件重新渲染 4、UseState() 5、UseReducer() 6、UseSyncExternalStore() 7、UseSelector() 8、UseDispatch() 二、自定义hook 命名以 use 开头 函数内部可以调用其他hook 三、hook使用规则 只能在函数最外层调用hook，不能在循环、条件判断或者子函数调用 函数组件中调用hook、或者在自定义hook中调用hook powered by GitbookFile Modify: 2024-10-30 23:55:26 "},"book/web/react/06-cra项目搭建.html":{"url":"book/web/react/06-cra项目搭建.html","title":"六、React CRA 项目搭建","keywords":"","body":"项目初始化 使用 create-react-app 搭建项目 // 全局安装 cra yarn add create-react-app global // 创建 cra ts 项目 npx create-react-app web --template typescript 路由组件配置管理 使用 react-router-config 集中式配置 react 路由，拥有 vue 配置路由的体验 使用 react-loadable 对组件进行异步加载处理 使用 react-router-dom 管理单页路由的跳转 安装依赖 // 安装 react-router-config yarn add react-router-config --development // 安装对应的类型声明 yarn add @types/react-router-config --development // 安装 react-loadable yarn add react-loadable --development // 安装对应的类型声明 yarn add @types/react-loadable --development // 安装 react-router-dom yarn add react-router-dom --development // 安装对应的类型声明 yarn add @types/react-router-dom --development 在根组件 App.tsx 中注册路由 import React from 'react'; import { renderRoutes } from 'react-router-config'; import { HashRouter } from 'react-router-dom'; import routes from './routers/index'; const App = () => ( {renderRoutes(routes)} ); export default App; react-router-config 接收一份路由配置，在 src 下新建 routers 文件夹管理路由 // ./src/routes/index.ts import Loadable from 'react-loadable'; import { RouteConfig } from 'react-router-config'; // 自定义 loading 组件 import Loading from '../components/Loading'; const routes: RouteConfig[] = [ { path: '/', exact: true, component: Loadable({ loader: () => import('../pages/home'), loading: Loading, }), } ]; export default routes; 修改 webpack 配置 修改 webpack 配置有两种方案 npm run eject 不可逆，暴露 create-react-app webpack 配置 使用 react-app-rewired 和 customize-cra 安装依赖 yarn add customize-cra react-app-rewired --development 修改目录下 package.json 文件 { \"scripts\": { \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewird test --env=jsdom\", } } 在项目根目录下添加 config-overrides.js 文件，在该文件中配置 webpack powered by GitbookFile Modify: 2024-10-31 12:06:37 "},"book/web/react/07-性能优化.html":{"url":"book/web/react/07-性能优化.html","title":"七、React性能优化","keywords":"","body":"一、使用纯组件，减少不必要渲染 1、shouldComponentUpdate 2、PureComponent 3、React.memo() 二、数据缓存 1、useMemo 缓存参数 2、useCallBack 缓存函数 3、函数，对象进行不要使用内联形式 Boolean({a:1} === {a:1}) 为 false 4、Router 中的内联函数渲染的时候使用render或者children，不要使用component 使用component时候，每次都会创建一个新组件，组件不用更新时候也会 三、不要滥用功能，如context、props 四、懒加载，对于长页列表分页加载 五、减少http请求 总结：减少计算、渲染和请求 powered by GitbookFile Modify: 2024-10-30 22:20:31 "},"book/web/javascript/":{"url":"book/web/javascript/","title":"JavaScript","keywords":"","body":"powered by GitbookFile Modify: 2024-10-30 18:45:45 "},"book/web/javascript/01-语法基础.html":{"url":"book/web/javascript/01-语法基础.html","title":"一、语法基础","keywords":"","body":"一、语法 区分大小写 标识符 变量、函数、属性或函数参数的名称 第一个字符是字母、下划线或美元符号，其他的是字母、下划线、美元符号或数字 注释（C语言风格注释，当行注释和块注释） 严格模式（es3的不规范写法在这里被处理，不安全的活动抛错） 语句（标点符号和花括号） 二、关键字与保留字 关键字与保留字不能做标识符或属性名 三、变量 var 关键字（变量声明未初始化为 undefined） 变量作用域 分为全局作用域和函数作用域，退出作用域变量销毁 变量声明不加 var 为全局变量 window 对象属性 变量声明提升 所有变量声明都拉到了函数作用域的顶部 只把变量声明提升，赋值操作不提升 let 声明（块级作用域） powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/javascript/02-操作符.html":{"url":"book/web/javascript/02-操作符.html","title":"二、操作符","keywords":"","body":"操作符 ECMA操作符包括算术操作符（加减号）、位操作符、关系操作符和相等操作符。与其他语言的不同之处在于，他们能够适用于很多值，例如：字符串、数值、布尔值，甚至对象。不过应用在对象上通常会调用对象的 valueOf() 或 toString() 方法，以便取得操作值 一元操作符 含义：只能操作一个值的操作符叫做一元操作符 分类：一元递增递减操作符、一元加减操作符 一元递增递减操作符： 前置递增递减操作符，变量的值都是在语句被求值之前被改变的var a1 = 2; var c = --a1 + 2; // 求值之前被改变 console.log(c); // 2 后置递增递减操作符，变量的值都是在语句被求值之后改变的var a2 = 2; var d = a2-- + 2; // 求值之后被改变 console.log(d); // 3 递增递减操作符用于除了整数的其他类型外，遵循先类型转换，在执行操作的规则var e1 = '2'; var f1 = --e1 + 2; var e2 = 'a'; var f2 = --e2 + 2; var e3 = true; var f3 = --e3 + 2; var e4 = false; var f4 = --e4 + 2; var e5 = 1.3; var f5 = --e5; var e6 = { valueOf: function() { return 1; } } var f6 = --e6; var e7 = { valueOf: function() { return 'a'; } } var f7 = --e7; console.log(f1); // 数字3 console.log(f2); // NaN console.log(f3); // 数字2 console.log(f4); // 1 console.log(f5); // .3 console.log(f6); // 0 console.log(f7); // NaN 一元加减操作符： 一元加放在数值前面，不会产生任何影响，放在非数值前面，改操作符会像 Number() 转型函数一样执行转换 一元减用于非数值前面，和一元加执行相同操作，最后再将得到的数值转为负数 位操作符 ECMA中所有数值都是 IEEE-754 64位格式存储，但位操作不直接操作64位的值，而是将64位的值转为32位整数在执行操作，最后再将结果转换回64位。对于开发人员来说，这个过程就像只存在32位整数一样 对于有符号的整数，32位中前31位表示整数，第32位表示符号位：0表示整数，1表示负数。第32位叫做符号位，决定了其他位数数值的格式 正数以纯二进制格式存储，负数以二进制补码存储 计算二进制补码过程： 求这个数值的二进制码 0000 0000 0000 0000 0000 0000 0001 0010 求二进制反码（即0，1互换） 1111 1111 1111 1111 1111 1111 1110 1101 得到的二进制反码加11111 1111 1111 1111 1111 1111 1110 1101 1 --------------------------------------- 1111 1111 1111 1111 1111 1111 1110 1110 ecmascript 会尽力隐藏这些所有信息，在以二进制字符串形式输出一个负数时，只会看到在前面加了一个符号var g1 = 18; var g2 = -18; console.log( g1.toString(2) ); // 10010 console.log( g2.toString(2) ); // -10010 ecmascript 对数字应用位操作符，会在后台发生如下的转换过程 将64位数值转化为32位 执行位操作 在转化为64位 副效应：NaN 和 Infinity 在应用位操作时，会被当为0处理 对非数字应用位操作符时，先转换成数字，在执行位操作 按位非（NOT） 按位非操作符由一个（～）表示，执行的结果就是返回数值的反码 var h1 = 18; // 0000 0000 0000 0000 0000 0000 0001 0010 var i1 = ~h1; // 1111 1111 1111 1111 1111 1111 1110 1101 // 18的反码，这个数为负数 // // 1111 1111 1111 1111 1111 1111 1110 1100 // 反码减1 // // 0000 0000 0000 0000 0000 0000 0001 0011 // 求反码，得到这个数正数的二进制码 console.log(i1); // -19 执行按位非的本质，操作数的负值减1 console.log(~18) console.log(~-20) 按位与（AND） 两个数值对应二进制位数都是1才返回1 var i1 = 2; var i2 = 4; console.log(i1.toString(2)); // 2 = 0000 0000 0000 0000 0000 0000 0000 0010 console.log(i2.toString(2)); // 4 = 0000 0000 0000 0000 0000 0000 0000 0100 console.log(i1 & i2); // AND = 0000 0000 0000 0000 0000 0000 0000 0000 按位或（OR） 两个数值对应二进制位数有一个是1返回1 var j1 = 2; var j2 = 4; console.log(j1.toString(2)); // 2 = 0000 0000 0000 0000 0000 0000 0000 0010 console.log(j2.toString(2)); // 4 = 0000 0000 0000 0000 0000 0000 0000 0100 console.log(j1 | j2); // OR = 0000 0000 0000 0000 0000 0000 0000 0110 按位异或（XOR） 两个数值对应二进制位数只有一个是1返回1 var k1 = 2; var k2 = 4; console.log(k1.toString(2)); // 2 = 0000 0000 0000 0000 0000 0000 0000 0010 console.log(k2.toString(2)); // 4 = 0000 0000 0000 0000 0000 0000 0000 0100 console.log(k1 ^ k2); // XOR = 0000 0000 0000 0000 0000 0000 0000 0110 左移（ 左移不会影响符号位 var l1 = 2; var l2 = l1 有符号的右移（>>） 保留符号位（移动31位） var m1 = 64; var m2 = m1 >> 5; console.log(m1.toString(2)); // 64 = 0000 0000 0000 0000 0000 0000 0100 0000 console.log(m2.toString(2)); // 64 >> 5 = 0000 0000 0000 0000 0000 0000 0000 0010 console.log(m2); // m2 2 无符号的右移（>>>） 不保留符号位（移动32位） 对负值影响较大 var n1 = -64; var n2 = n1 >>> 5; console.log(n1.toString(2)); // 64 = 0000 0000 0000 0000 0000 0000 0100 0000 // // 1111 1111 1111 1111 1111 1111 1011 1111 // // 1111 1111 1111 1111 1111 1111 1100 0000 console.log(n2.toString(2)); // -64 >>> 5 = 0000 0111 1111 1111 1111 1111 1111 1110 console.log(n2); // n2 134217726 powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/webpack/":{"url":"book/web/webpack/","title":"Webpack","keywords":"","body":"powered by GitbookFile Modify: 2024-10-30 18:45:45 "},"book/web/webpack/01-webpack基础.html":{"url":"book/web/webpack/01-webpack基础.html","title":"一、webpack基础","keywords":"","body":"一、什么 Webpack webpack 是一个打包模块化的 javascript 工具，它会从入口模块出发，识别出源码中的模块化导入语句，递归地找出入口文件的所有依赖，将入口和其所有的依赖打包到一个单独的文件中，是工程化、自动化思想在前端开发中的体现。 一、安装 // 依赖安装 npm i -D webpack webpack-cli 本地安装方式启动：npx webpack 查看各个阶段耗时：npx webpack --profile 二、webpack 默认配置 执行 npx webpack 时候会默认寻找 webpack.config.js 配置文件； 默认入口为 src/index.js； 默认出口为 dist/main.js; 默认 mode 为 production； 配置参数 context 用于配置项目打包的相对路径，默认为根目录； 默认支持 json 和 js 模块，默认后缀名为 .json 、.js。 三、webpack 核心概念 1. entry webpack 入口，执行 npx webpack 之后会在 entry 字段下找对应的文件入口地址，支持单入口、多入口。 单入口： // 方式一：接收一个 string module.exports = { entry: './src/index.js' }; // 方式二：接收一个 array module.exports = { entry: ['./src/index.js', './src/other.js'] }; 多入口： // 接收一个对象，key 为入口 module.export = { entry: { index: './src/index.js', other: './src/other.js' } }; 2. output webpack 打包出口位置，出口文件是一个对象。 const path = require('path'); module.exports = { // path：必须为绝对路径 path: path.reslove(__dirname, './dist'), // filename：构建文件名字，支持占位符输出 filename: '[name].js' }; 3. bundle webpack 对文件进行打包生成的静态文件资源被称为 bundle，1 chunk = 1 bundle = 一个文件 4. loader webpack 处理不认识的模块的时候，会到 module 列表中找到对应的正则匹配规则，应用对应的 loader 来增强对其他格式文件的处理；如果匹配到规则，就按照 loader 列表中的顺序从后往前加载 loader 处理文件。 5. plugin 作用于整个打包过程，对 webpack 不具备的功能进行扩展。 四、webpack 占位符 hash 每次构建都会生成、即使文件没有改 默认长度20，可以指定长度[hash:16] chunkHash 根据不同入口 entry 进行依赖解析，构建对应 chunk 只要组成 entry 的模块没有内容改变，则对应的 hash 不变 多入口可以使用 chunkhash contentHash 父 chunk 改变，子 chunk 不变，子 chunk 使用 contentHash 时候就不会随着父 chunk 改变而改变 name bundle 名称 powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/webpack/02-webpack常用配置.html":{"url":"book/web/webpack/02-webpack常用配置.html","title":"二、webpack常用配置","keywords":"","body":"一、样式的处理方式 1. 常用 loader、plugin 安装 npm i -D style-loader css-loader sass-loader node-sass postcss-loader autoprefixer 2. 配置 postcss 在项目目录下新建 postcss.config.js 文件，webpack 执行构建时候会自动读取该文件配置，配置方式如下： const autoprefixer = require('autoprefixer'); module.exports = { plugins: [autoprefixer({ overrideBrowserslist: [\"last 2 versions\", \">1%\"], })] } 3. 配置 webpack.config.js webpack 处理过程： 首先使用 sass-loader 对 .scss 文件中语法进行转换； 在将编译后的文件交给 postcss 进行处理； 然后使用 css-in-js 方式将 css 插入到 js 代码中去； 最后使用 style-loader 解析出 css 代码，在页面创建 style 标签插入页面中去。 module.exports = { module: { test: /\\.scss$/, use: [ // 从 js 中提取出来并且创建 style 标签插入页面中 'style-loader', // 插入到 js 中 { loader: 'css-loader', options: { // 开启 css 模块化 modules: true, }, }, // 编译后 css 进行 postcss 后处理 { loader: 'postcss-loader', }, // scss loader 先处理编译 css 'sass-loader', ], }, }; 二、静态资源的处理 1. 字体的处理 依赖安装 npm i -D file-loader 在 css 中定义字体 @font-face { font-family: 'webfont'; font-display: swap; // 下载下来的字体本地路径 src: url('webfont.woff2') format('woff2'); } webpack 规则配置 module.exports = { module: { rules: [ { // 匹配字体规则 test: /\\.(eot|ttf|woff|woff2|svg)$/, use: 'file-loader', } ], } }; 2. 图片的处理 url-loader url-loader 与 file-loader 功能一致，并且多了一个 limit 配置，可以根据文件大小确定生成 bundle 还是使用 base64 数据。 依赖安装 npm i -D url-loader webpack 配置 module.exports = { module: { rules: [ { test: /\\.(png|jpe?g|gif)$/, use: [ loader: 'url-loader', options: { // ext 文件后缀名 name: \"[name]_[hash:6].[ext]\", // 输出目录 outputPath: 'images/', // 推荐使用 url-loader 因为支持 limit，单位字节 limit: 2 * 1024, } ], }, ], } }; 三、处理 html 模块文件 对 html 处理，一个是对模块文件进行预配置，第二是每次生成的时候对打包文件路径进行清理。 依赖安装 npm i -D html-webpack-plugin clean-webpack-plugin webpack 配置 const HtmlWebpackPlugin = require('html-webpack-plugin'); const CleanWebpackPlgin = require('clean-webpack-plugin'); module.exports = { plugin: [ new new HtmlWebpackPlugin({ // 选择模板 template: './src/index.html', filename: 'index.html', // 资源注入位置 (true | 'body') | 'head' | false inject: true, // 开启压缩 {} | false minify: false, // 网站 icon favicon: '', // title 设置方式 // 1. 这里设置 title // 2. 模块默认支持 ejs，在模板内引用 title 变量 // - title: '首页' }) ] }; 四、SourceMap 配置 开发模式默认开启，生产模式推荐配置如下。 module.exports = { // 推荐配置 devtool: 'eval-cheap-module-source-map' } 五、WebpackDevServer webpack 本地开发服务器，每次修改代码需要重新打包，利用 devserver 提高效率（基于express） 依赖安装 npm i -D webpack-dev-server // 启动 npx webpack server 本地开发服务搭建： const webpack = require('webpack'); module.exports = { devServer: { // 设置目录路径 contentBase: \"./dist\", // 是否打开浏览器 open: true, // 端口 port: 8080, // 开启 css 热更新 hot: true, // 即便 HMR 没有生效，浏览器也不要自动刷新 hotOnly: true // 代理设置 proxy: { \"/api\": { target: \"http://localhost:9090\" } }, // 在 webpack-dev-server 静态资源中间件处理之前，可以用于拦截部分请求返回特定内容，或者实现简单的数据 mock。 before(app, server) { app.get(\"/api/info\", (req, res) => { res.json({hello: \"express\"}); }) }, // 在 webpack-dev-server 静态资源中间件处理之后，比较少用到，可以用于打印日志或者做一些额外处理。 after() {}, }, plugins: [ // css 热更新配置 new webpack.HotModuleReplacementPlugin() ] // js 热更新配置使用 react-hot-loader } 六、使用 babel 处理 jsx 依赖安装 npm i -D @babel/core @babel/preset-env @babel/preset-react babel-loader bable.config.js 配置 module.exports = { presets: [ [ \"@babel/preset-env\", { targets: { edge: \"17\", firefox: \"60\", chrome: \"67\", safari: \"11.1\", }, corejs: 2, // entry 在入口引入一次，按需引入 // usage 不需要 import，全自动检测 // false 不会按需引入 useBuiltIns: \"usage\", } ], \"@babel/preset-react\" ], }; webpack 配置 module: { rules: [ { exinclude: /node_modules/, test: /.jsx?$/, use: { loader: 'babel-loader' } }, ], }; 七、js 代码兼容 依赖安装 npm i -S polyfill npm i -D @babel/plugin-transform-runtime npm i -S @babel/runtime 当 babel 兼容不了的写法的时候，使用 polyfill 第三方库进行兼容，他不会转换代码。 当开发组件库时候，polyfill 不适合了，因为注入的是全局变量，所以推荐使用闭包方式，配置如下： module.exports = { plugins: [ { \"@babel/plugin-transform-runtime\", { absoluteRuntime: false, corejs: false, helper: true, regenerator: true, useESModules: false, } } ] }; powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/webpack/03-webpack优化配置.html":{"url":"book/web/webpack/03-webpack优化配置.html","title":"三、webpack优化配置","keywords":"","body":"一、优化打包体验 1. 缩小文件范围 loader是一个消耗性能的大户，进行 loader 匹配时候，使用 include（包含） exclude（排除） 缩小文件检索范围，提高构建速度 2. 限制文件查找范围 限制模块查找范围，定位到当前项目下的 node_modules module.exports = { resolve: { modules: [path.resolve(__dirname, \"./node_modules\")] } }; 3. 减少查找过程 通过别名设置多次引用依赖的路径地址，减少查找过程 module.exports = { resolve: { alias: { // 设置 react react-dom 路径，减少查找 \"react\": './node_modules/react/umd/react.production.min.js', \"react-dom\": './node_modules/react-dom/umd/react-dom.production.min.js', \"@css\": './src/assets/css', } } }; 4. 优化 cdn 静态资源 设置之后，打包时候不打包 cdn 资源，而是在模板中手动引入，打包速度更快。 index.html 模板中手动引入 webpack 配置了 externals 之后，webpack 对他不进行打包，需要在模板手动引入 module.exports = { externals: { lodash: '_' } }; 5. 静态资源使用 cdn 方式 使用 cdn 方式，优化第一次访问速度，第二次走缓存都一样了。 module.exports = { output: { // 需要手动上传打包后 js 文件 filename: '[name].js' publicPath: 'http://cdn.com/js/' } }; 6. 压缩 Css、Html html 在 html-webpack-plugin 中配置，css 生产模式使用 optimize-css-assets-webpack-plugin 安装 npm i -D optimize-css-assets-webpack-plugin html-webpack-plugin css 压缩 const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin'); module.exports = { plugins: [ { new OptimizeCSSAssetsPlugin({ cssProcessor: require('cssnano'), cssProcessorOptions: { discardComments: { removeAll: true }, } }) } ] }; html压缩 const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { plugin: [ new HtmlWebpackPlugin({ minify: { removeComments: true, collapseWhitespace: true, minifyCSS: true, }, }) ] }; 7. dev 与 pro 打包区分 抽取出公共配置与 dev、pro 配置文件； 使用 webpack-merge 合并出 dev、pro 配置； 通过 mode 区分打包 8. TreeShaking \"摇树\"，清除无用的代码，即 Dead Code Dead Code 一般具有以下几个特征： 代码不会被执行， 代码执行结果不被用到 代码只会影响死变量 js tree shaking 只支持 ES module 的引入方式 依赖安装 npm i glob-all purify-css purifycss-webpack -D webpack 配置 const PurifyCSS = require('purifycss-webpack') const glob = require('glob-all'); module.exports = { // css treeshaking pulgins: [ new PurifyCSS({ path: glob.sync([ path.resolve(__dirname, \"./src/*.html\"), path.resolve(__dirname, \"./src/*.js\") ]) }) ] // js treeshaking // 生产模式下生效，开发模式为了方便调试，不生效。 optimization: { usedExports: true // 哪些导出的模块被使用了，在做打包 } }; 排除 treeshaking 规则，在 package.json 中 sideEffects 字段配置，可设置不对 treeshaking 生效的范围 { sideEffects: [ './src/*.scss' ] } 9. 加载优化 使用魔法注释，进行 prefetch、preload prefetch: 当浏览器发现进程空闲时候，会请求一些异步模块（比如点击时候触发的模块） preload: 预先加载，不管是否空闲，比较重要先展示的一些模块 使用 import() 语法时候加上注释，开启魔法注释 // 生成 并追加页面头部 import(/* webpackPrefetch: true */, 'moduleName'); // import(/* webpackPreload: true */, 'moduleName'); 10. scope hoisting webpack 通过 ES6 语法的静态分析，分析出模块之间的依赖关系，尽可能的把模块放在同一个函数中，优化 bundle 文件体积 module.exports = { optimization: { concatenateModules: true } }; 11. HappyPack 并发执行任务 运行在 Node 之上的 webpack 是单线程模型的，也就是说 webpack 需要一个个地处理任务，不能同时处理多个任务，HappyPack 就能让 webpack 做到这一点，它将任务分解给多个子进程去并发执行，子进程处理完再将结束发送给主进程，从而发挥多核 CPU 电脑的威力。 依赖安装 yarn add happypack --development webpack 配置 const os = require('os'); const HappyPack = require('happypack'); const happyThreadPool = HappyPack.TheadPool({ size: os.cpus().length }) module.exports = { module: { rules: [ { test: /.jsx?$/, use: [ { loader: \"happypack/loader?id=babel\" } ] }, { test: /\\.s?css$/, use: [\"happypack/loader?id=css\"] } ], } plugins: [ new HappyPack({ id: 'babel', loaders: ['babel-loader'], // 共享进程池 功能慎用，项目较小构建时间反而增加了 threadPool: happyThreadPool }), new HappyPack({ id: 'css', loaders: [ 'style-loader', { loader: 'css-loader', options: { modules: true } }, 'postcss-loader', 'scss-loader' ] }) ] }; 与 min-css-extract-plugin 配合不好 二、优化开发体验 1. 设置后缀（不推荐） webpack 默认支持 .js、.json，设置后缀后写法上舒服，但是推荐带上后缀，减少查找。 module.exports = { resolve: { extensions: ['.js', '.json', '.jsx', '.ts'] } }; 2. Dll 抽取 dll 动态链接库，做缓存，只会提升 webpack 打包速度，并不能减少最后生成代码体积。 对依赖提前编译，进行缓存 webpack 已经内置了对动态链接库的支持 DllPlugin: 用于打包出一个个单独的动态链接库文件 DllReferencePlugin: 用于在主要配置的文件中引入 DllPlugin 插件打包好的动态链接库文件 新建 webpack.config.dll.js文件，打包基础模块 const { DllPlugin } = require('webpack'); const path = require('path'); module.exports = { mode: 'development', entry: { react: ['react', 'react-dom'], }, output: { path: path.resolve(__dirname, './dll'), filename: '[name].dll.js', library: 'react', }, plugins: [ new DllPlugin({ path: path.join(__dirname, './dll', '[name]-manifest.json'), name: 'react' }) ] } package.json 中配置命令 { \"script\": { \"build:dll\": \"webpack --config ./webpack.config.dll.js\" } } 使用 npm run build:dll 后会在根目录下生产 dll 文件夹，在模板文件中手动引入 dll 文件夹下的 reatc.dll.js。 通过这种方式，打包时候不打包 dll 已经打包的文件。 不能同时和代码分割、依赖别名设置同时使用 三、二者兼具 1. CodeSpliting 单页面 spa： 打包后，所有页面只生成一个 bundle.js 代码体积变大，不利于下载 没有合理利用浏览器资源 多页面应用 mpa： 如果多个页面引入一些公共模块，可以把公共模块抽离出来，单独打包，公共代码只需要下载一次缓存起来，避免重复下载。 默认写入 splitChunks: { chunk: 'all' } 会把引用次数为1，体积大于 30kb 的分割出去 webpack 配置 module.exports = { optimization: { splitChunks: { // all 支持两种模块 // async // initial chunk: 'all', // 模块分割最小尺寸 minSize: 30000, // 对模块进行二次分割时使用 maxSize: 0, // 打包生产的 chunk 文件最少有几个 chunk 引用了这个模块 minChunks: 1, // 最大异步请求数 maxAsyncRequest: 5, // 打包分割符号 automaticNameDelimiter: '-', // 打包后的名字，可以就收布尔值或者函数 name: true, // 分成多个组文件 cacheGroups: { lodash: { test: /lodash/, name: 'lodash', }, react: { test: /react|react-dom/, name: 'react', // 优先级 priority: 10 } } } } }; 四、性能分析工具 1. 测量 Plugin 与 Loader 耗时 依赖安装 npm i -D speed-measure-webpack-plugin webpack 配置 const SpeedMeasurePlugin = require('speed-measure-webpack-plugin'); const smp = new SpeedMeasurePlugin(); // webpack 配置 const config = {}; module.exports = smp.wrap(config) 2. 分析 webpack 打包后的模块依赖关系 分析 webpack 打包后的模块依赖关系，启动 weback 时候会默认打开一个窗口 依赖安装 npm i -D webpack-bundle-analyzer webpack 配置 const BundleAnalyZerPlugin = require('webpack-bundle-analyzer').BundleAnalyZerPlugin; module.exports = merge(baseWebpackConfig, { plugins: [ new BundleAnalyZerPlugin(), ] }) powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/webpack/04-webpack打包原理.html":{"url":"book/web/webpack/04-webpack打包原理.html","title":"四、webpack打包原理","keywords":"","body":"一、webpack 构建 bundle 原理分析实现 webpack 启动后会接受一份配置 通过 fs 模块读取配置内容，拿到入口 通过 @babel/parser 模块将配置内容转成抽象语法树 AST 通过 ast 拿到对应的 dependencies、code、entryFile 通过 for 循环递归拿出所有的依赖，生成 code 拿到 code 去做生成器函数并输出到 dist 目录 powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/webpack/05-webpack自定义.html":{"url":"book/web/webpack/05-webpack自定义.html","title":"五、webpack自定义","keywords":"","body":"一、自定义 Loader 实现 一个loader就是一个Node.js 模块，这个模块需要导出一个函数，这个导出的函数的工作就是获得处理前的源内容，对源内容进行处理后，返回处理后的内容。 自定义一个 loader // ./src/loaders/replace-loader.js module.exports = function(source, sourceMap, ast) { // 通过 this.query 接收配置传递的参数 const { str } = this.query; return source.replace('aaa', str); }; webpack 中使用 const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const { CleanWebpackPlugin } = require('clean-webpack-plugin'); module.exports = { entry: './src/index.js', mode: 'development', output: { path: path.resolve(__dirname, './dist'), filename: '[name].js', }, // 定义自定义 loader 所在位置 resolveLoader: { modules: ['node_modules', './src/loaders'] }, module: { rules: [ { test: /.js$/, use: { loader: 'replace-loader', options: { str: 'bbb' } } } ] }, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin({ template: './src/index.html', }) ], devServer : { contentBase: './dist' } }; loader 的两种返回方式 // return source module.exports = function (source) { return source; } // this.callback() module.exports = function (source) { this.callBack(null, source); } this.callback 详细用法 this.callback( // 当无法转换源内容时，给 Webpack 返回一个 Error err: Error | null, // 源内容转换后的内容 content: string | Buffer, // 用于把转换后的内容得出原内容的 Source Map，方便调试 sourceMap?: SourceMap, // 如果本次转换为原内容生成了 AST 语法树，可以把这个 AST 返回， // 以方便之后需要 AST 的 Loader 复用该 AST，以避免重复生成 AST，提升性能 abstractSyntaxTree?: AST ); 异步 loader module.exports = function(source, sourceMap, ast) { const { str } = this.query; // 使用 this.async 处理异步 loader const cb = this.async(); setTimeout(() => { cb(null, source.replace('aaa', str)) }, 2000) }; 二、自定义 Plugin 实现 powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/nodejs/":{"url":"book/web/nodejs/","title":"NodeJs","keywords":"","body":"powered by GitbookFile Modify: 2024-10-30 18:45:45 "},"book/web/nodejs/01-core.html":{"url":"book/web/nodejs/01-core.html","title":"一、Nodejs 核心","keywords":"","body":"node 特点 javascript 运行时环境（什么叫运行时） 非阻塞I/O（查资料） 事件驱动（查资料） 并发处理历史进程 多进程 c 多线程 java 异步IO js 协程 lua openresty go docker nodemon 工具 文件变化，自动重启，利于调试 vs code 中 nodejs debug 查资料了解 nodejs 第三方库 cpu-stat cpu状态 异步处理 promisity（了解） async/await powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/nodejs/02-net.html":{"url":"book/web/nodejs/02-net.html","title":"二、Nodejs 网络通信","keywords":"","body":"网络通信 osi参考模型 物理层 数据链路层 网络层 传输层 会话层 表示层 应用层 tcp/ip模式 以太网、无线（1、2） 网络层（3） 传输层（4） 应用层（5、6、7） 通常是在传输层与应用层进行编程 HTTP 状态码 1xx：已经接收，继续处理 2xx：成功 3xx：重定向 4xx：客户端错误 5xx：服务器错误 了解常用的状态码 200、400、401、403、404、500、503 跨域 简单请求：get、post跨域（后端加入可允许访问源） 预检请求：put、delete等都有options类型请求，设置header nginx 反向代理（含义） 实战爬虫 cheerio iconv-lites request HTTP2 多路复用 服务器推送 首部压缩 了解 jsonrpc thrift preeflight request mactalk credential 请求 web uploader 工具 live-server process on 思维导图 swagger kibanna es 目标 使用 socket.io 编写一个聊天工具 看课件 实战爬虫 o-my-zsh + iterm powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/nodejs/03-mongodb.html":{"url":"book/web/nodejs/03-mongodb.html","title":"三、Nodejs 数据持久化","keywords":"","body":"mongo 命令行 数据库操作： 查看所有数据库（为空的不显示）：show dbs 正在使用的数据库：db 切换数据库（不存在，则新建）：use 表操作： 查看表：db.collections 表插入： 新增一条数据：db.collection.insert(data) 新增多条数据：db.collection.insertMany([data1, data2, ...]); 表删除： 删除数据：db.collection.remove(condition) 表查询操作： 查看所有数据：db.collection.find() 相当于 db.collection.find({}) 可以增加第二个参数，自定义返回字段 db.collection.find({}, {key: 1, _id: 0}) id的默认为1，默认返回，0为不返回 按条件查询数据：db.collection.find(condition) collection 里面可以使用正则进行匹配 查询条件：db.find({key: {$gt: num, $lt: num}}) $gt $gte $lt $lte $ne != $in $nin（在一个字段中查找） $or（可以是多个字段） $type Double 1 String 2 Object 3 Array 4 Boolean 8 Date 9 Null 10 REGEXP 11 以上常用、其他不列举了... $not $and 表更新操作 更新数据（只会更新满足条件的第一个，一条数据的所有字段）：db.collection.update(condition, newVal); 更新多条数据中的一个字段：db.collection.update(condition, {$set: newVal}, false, true) 第三个参数代表，如果未查询到更新数据，是否插入一条，默认false，不插入 第四个参数代表，查询到更新数据之后，是否更新多条 增加已有键的值，如果没有则新建（更新满足条件的第一个）：db.collection.update(condition, {$inc: newVal}) 向已有数组尾部追加一个元素，如果没有就创建新数组：db.collection.update(condition, {$push: newVal}) 向已有数组尾部追加多个元素：db.collection.update(condition, {$push: {newValKey: {$each: newValArray}}}) slice 固定数组长度，不足则添加，多了则会保存最新的固定长度：db.collection.update(condition, {$push: {newValKey: {$each: newValArray, $slice: fixNum}}}) fixNum 为负数，当元素溢出的时候，保存最新的 fixNum 为整数，当元素溢出的时候，保存最先添加进去的 向数组添加一个元素，如果数组不存在则创建，添加元素不存在则添加，否则，不添加：db.collection.update(condition, {$addToSet: newVal}) 向数组添加多个元素，如果数组不存在则创建，添加元素不存在则添加，否则，不添加：db.collection.update(condition, {$addToSet: {$each: [newVal1, newVal2, ...]}}) 删除数组中一个元素：db.connection.update(condition, {$pop: key: num}) num 为 1 则表示从尾部删除， -1 表示从头部删除 按条件删除数组中的元素（可以是多个）：db.connection.update(condition, {$pull: newVal}) 访问数组下标 array.0（数组第0个元素） db.collection({a: 1}, {$set: {a.$: 2}}) ​$表示当前满足条件的索引 save 接受一个参数，这个参数就是文档，当文档里面有 _id 参数则表示更新，否则为插入操作 powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/nodejs/04-koa.html":{"url":"book/web/nodejs/04-koa.html","title":"四、Nodejs koa 框架","keywords":"","body":"context 对象 req res request response state app 中间件 顺序执行的需要 切面描述的需要，横向（鉴权、错误处理、日志） AOP 编程 语言级 - java 框架级 常用中间件 错误中间件（提交代码健壮性） 中间件错误 try/catch 应用级错误 error 事件 严重错误 抛错 Hash 算法（SHA MD5） 含义 将一个不定长的摘要定长结果 满足条件 摘要（不可逆，防串改） 雪崩效应（密文微小变化，明文剧烈变化） 后端算法 摘要 对称 DES 非对称 RSA koa 鉴权 Session/Cookie cookie 约定头，Set-Cookie 相关方法 取值 cookie req.headers.cookie 设置 res.setHeader('Set-Cookie', 'username=a') 缺点 js 可以直接读取，不安全 cookie 太小 cookie 同源策略 优化方式 通过 cookie session 模式，后端存储键值对的key在前端，键值存储在后端，解决了安全和大小 通过 redis 全局化 session（解决多台node服务器cookie不同源） axios 中配置 中请求拦截器中设置 config.headers.common[\"Authorization\"] = \"Bearer \" + token; Token token 放在header，遵循 jwt 约定 config.headers.common['Authorization'] = \"Bearer \" + token; token 组成 第一部分令牌头，base64 编码 第二部分payload，base64 编码 第三部分hash，对前面部分进行签名 OAuth（开放授权） github - 授权码登录 发出授权请求，通过 302 到第三方授权（需要client id） 成功之后，通过 302 到自己的服务器设置的 callback 请求（callback 之后返回 code） callback 请求之后，通过 gettoken 获取真正的 token（gettoken 换取 token 需要 id、密码、code） 通过 token 请求 user 接口，得到个人信息 restful linux 公钥信任 linux 命令 查看 cat tail vi powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/nodejs/05-egg.html":{"url":"book/web/nodejs/05-egg.html","title":"五、Nodejs egg 框架","keywords":"","body":"后端的三层模式 界面层 接收数据请求，返回数据结果及界面效果展示 别名：表现层、外观层 业务逻辑层 对数据业务需求逻辑进行实现处理 别名：领域层 数据访问层 增删改查 别名：持久层 MVC 模式 egg 分层 路由 控制器 restful 页面请求 代理服务器 服务 数据层 mongoose sequelize powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/nodejs/06-deploy.html":{"url":"book/web/nodejs/06-deploy.html","title":"六、Nodejs 部署","keywords":"","body":"Docker 是什么 Build，Ship and Run Any App，Anywhere 一次封装，到处运行。 基于 Linux 的高效、敏捷、轻量级的容器（轻虚拟化）方案。 完全虚拟化 VMware Workstation、VirtualBox 硬件虚拟化技术 InterVT AMD-T 超虚拟化 Xen 操作系统级 Docker LXC容器 特点： 高效的利用系统资源 快速的启动时间 一致的运行环境 持续交付与部署 更轻松的迁移 Docker 安装 申请云服务器 购买 ubuntu 服务器 生成公钥 ssh-keygen -t rsa 上传公钥到服务器 ssh-copy-id root@[serverName] 登录 ssh root@[serverName] 安装常用软件与 Docker Docker 基本命令 // 简单启动 // 将虚拟机 /usr/share/nginx/html 目录映射到当前目录下的 www 下 // 将虚拟机的 80 端口映射到本机的 8000 端口 // 加上 -d 以后台模式启动进程，并且打印一个 uuid docker run -p 8000:80 -v $PWD/www:/usr/share/nginx/html -d nginx // 查看进程（加上 -a 查询所有的容器，包括没有启动的） docker ps -a // 停止进程 docker stop pid // 开启进程 docker start pid // 查看 Nginx 镜像 docker images nginx // 删除镜像 docker rm pid // 拉取镜像 docker pull nginx // 查看镜像 docker image nginx // 制作镜像（在当前目录下定制一个名字叫 myimage 镜像） docker build -t myimage . // 启动定制镜像（在 8000 端口后台运行 myimage 镜像） docker run -p 8000:80 -d myimage Docker 运行过程 镜像（Image）面向 docker 只读模板 容器（Container）镜像的运行实例 仓库（Registry）存储镜像的服务器 DockerFile 定制镜像 定制 nginx 镜像 FROM nginx:latest RUN 定制 nodejs 镜像 // node 10 lunix 经典版（更小） FROM node:10-alpine // 将 Dockerfile 所在目录文件拷贝到虚拟机的 /app/ 目录 ADD . /app/ // 进入 app 目录 WORKDIR /app // 执行 npm install RUN npm install // 暴露 3000 端口 EXPOSE 3000 // 执行 node app.js CMD [\"node\", \"app.js\"] 定制 pm2 镜像 FROM keymetrics/pm2:latest-alpine // 将 Dockerfile 所在目录文件拷贝到虚拟机的 /usr/src/app 目录 ADD . /usr/src/app // 进入 app 目录 WORKDIR /usr/src/app // 执行 npm install RUN npm install // 暴露 3000 端口 EXPOSE 3000 // 执行 node app.js CMD [\"pm2-runtime\", \"start\", \"process.yml\"] process.yml app: script: app.js instance: 2 watch: true env: NODE_ENV: production docker-compose 安装：apt install docker-compose 配置 docker-compose.yml version: '3.1' services: mongo: image: mongo restart: always ports: - 27017:27017 mongo-express: image: mongo-express restart: always ports: // 8081 镜像内部默认端口 - 8000:8001 启动：docker-compose up -d --force-recreate --build 关闭：docker-compose down 实战 nginx 使用 vs-deploy 在 .vscode/settings.json 中 配置 vs-deploy 配置 docker.conf 文件 server { listen: 80 location / { root /var/www/html index index.html index.htm } location ~ \\.(gif|jpg|png)$ { root /static index index.html index.htm } } 配置 docker-compose.yml version: '3.1' services: nginx: restart: always image: nginx ports: - 8091:80 volumes: // 映射 docker nginx 配置 - ./nginx/conf.d:/etc/nginx/conf.d // 映射输入目录 - ./frontend/dist:/var/www/html // 映射静态资源目录 - ./static/:/static/ 实战 nodejs 建一个高可用的 node 环境 故障恢复 充分多核资源的利用 多进程共享端口 cluster 模块 fork 模式 nodejs 中实现端口重用的原理 文件上传服务器 scp git deploy插件 pm2 内建负载均衡 线程守护 0秒停机重载 powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/nodejs/07-linux.html":{"url":"book/web/nodejs/07-linux.html","title":"七、Linux常用命令","keywords":"","body":"一、linux 常用命令 查看文件：cat filename 写入文件：echo \"hello\" >>> www/index.html 复制文件 scp local_folder remote_username@remote_ip:remote_folder 复制目录 scp -r local_folder remote_username@remote_ip:remote_folder 安装 curl sudo apt-get install curl 安装 nvm curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash 重启终端 source .bashrc powered by GitbookFile Modify: 2024-10-31 10:14:28 "},"book/web/typescript/":{"url":"book/web/typescript/","title":"TypeScript","keywords":"","body":"powered by GitbookFile Modify: 2024-10-30 18:45:45 "},"book/web/数据结构与算法/":{"url":"book/web/数据结构与算法/","title":"数据结构与算法","keywords":"","body":"powered by GitbookFile Modify: 2024-10-30 18:45:45 "},"book/web/数据结构与算法/01-链表.html":{"url":"book/web/数据结构与算法/01-链表.html","title":"一、链表","keywords":"","body":"链表 物理储存单元非连续、非顺序的储存结构，由一系列节点构成 节点用来存储数据。一部分是存储数据的数据域，一个部分是存储指向下一个节点的指针域 相关概念 首尾节点 链表中第一个节点是首节点，最后一个节点是尾节点 有头链表与无头链表 无头链表指的是第一个节点既有指针域，又有数据域，第一个节点既是首节点，又是头节点。 有头链表指的是第一个节点只有指针域，没有数据域。 链表相关生活例子 猴子捞月 定义链表类 function LinkList() { var Node = function(data) { this.data = data; this.next = null; } var length = 0; var head = null; // 头节点 var tail = null; // 尾节点 } 定义节点类，接收一个data参数，指定数据域属性，在指定指针域属性，当链表为空的时候，length为0，头节点和尾节点为空，新增节点后，head指向头节点，tail指向尾节点。 链表方法 append，添加一个新的元素 insert，在指定位置插入一个元素 remove，删除指定位置的元素 remove_head，删除首节点 remove_tail，删除尾节点 indexOf，返回指定位置的索引 get，返回指定位置的元素 head，返回头节点 tail，返回尾节点 length，返回链表长度 isEmpty，判断链表是否为空 clear，清空链表 print，打印整个链表 append 方法 function LinkList() { var Node = function(data) { this.data = data; this.next = null; } var length = 0; var head = null; var tail = null; // 添加节点 // 1. 修改最后一个节点的指针域（指向新节点） // 2. 修改最后一个节点的数据域为新节点 // 3. 更新 length 属性 this.append = function(data) { var newNode = new Node(data); if (head == null) { head = newNode; tail = newNode; } else { // 将指针域指向新节点，修改尾节点为新节点（先修改指针域） tail.next = newNode; tail = newNode } length += 1; return true; }; } print 方法 function LinkList() { var Node = function(data) { this.data = data; this.next = null; } var length = 0; var head = null; var tail = null; this.print = function() { // 当前节点为头节点 var curNode = head; while (curNode) { console.log(curNode.data); // 移动指针到下一个节点 curNode = curNode.next; } }; } var link = new LinkList(); link.append(2); link.append(3); link.append(5); link.print(); insert 方法 function LinkList() { var Node = function(data) { this.data = data; this.next = null; } var length = 0; var head = null; var tail = null; this.insert = function(index, data) { if (index length) { return false; } else if (index === length) { return this.append(data); } else { var newNode = new Node(data); if (index === 0) { newNode.next = head; head = newNode; } else { var insertIndex = 1; var curNode = head; // 找到插入节点的上一个节点 while (insertIndex remove 方法 function LinkList() { var Node = function(data) { this.data = data; this.next = null; } var length = 0; var head = null; var tail = null; // 删除 index 位置的元素就是把 index 前一个的 next 指向被删除元素的 next; this.remove = function(index) { if (index = length) { return null; } else { var delNode = null; // 第一个节点被删除，指针往前移动一个 if (index === 0) { delNode = head; head = head.next; } else { var delIndex = 0; var preNode = null; var curNode = head; while (delIndex get 方法 function LinkList() { var Node = function(data) { this.data = data; this.next = null; } var length = 0; var head = null; var tail = null; this.get = function(index) { if (index = length) { return null; } else { var curIndex = 0; var curNode = head; while(curIndex 链表常见面试题 链表反转（迭代和递归两种方法实现） 双向链表 迭代翻转链表 function Node(data) { this.data = data; this.next = null; } var node1 = new Node(1); var node2 = new Node(2); var node3 = new Node(3); var node4 = new Node(4); var node5 = new Node(5); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; function print(node) { var curNode = node; while(curNode) { console.log(curNode.data); curNode = curNode.next; } } function reverseInte(head) { if (!head) { return null; } var prevNode = null; var curNode = head; while(curNode) { var nextNode = curNode.next; curNode.next = prevNode; prevNode = curNode; curNode = nextNode; } return prevNode; } print( reverseInte(node1) ) 递归翻转链表 function Node(data) { this.data = data; this.next = null; } var node1 = new Node(1); var node2 = new Node(2); var node3 = new Node(3); var node4 = new Node(4); var node5 = new Node(5); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; function print(node) { var curNode = node; while(curNode) { console.log(curNode.data); curNode = curNode.next; } } function reverseDiGui(head) { if (!head) { return null; } if (head.next === null) { return head; } var newHead = reverseDiGui(head.next); head.next.next = head; head.next = null; return newHead; } print( reverseDiGui(node1) ) powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/数据结构与算法/02-堆栈.html":{"url":"book/web/数据结构与算法/02-堆栈.html","title":"二、堆栈","keywords":"","body":"栈的概念 栈是一种特殊的线性表，仅能在栈顶进行操作，有着后进先出的特性 栈的实现方式 数组 链表 栈的方法 push()，添加一个元素到栈 pop()，弹出栈顶元素 top()，返回栈顶元素 isEmpty()，判断栈顶是否为空 size()，返回栈的元素个数 clear()，清空栈 数组实现栈 function Stack() { var items = []; this.push = function(item) { items.push(item); } this.pop = function() { return items.pop(); } this.top = function() { return items[items.length - 1]; } this.size = function() { return items.length; } this.isEmpty = function() { return items.length === 0; } this.clear = function() { items.length = 0; } } 栈的应用 合法括号判断 var str = '(sssd(sss)ss(aadaf))'; var str2 = '(asdasd)(asd)sad)adsad(asd'; var isLeaglBrackets = function(string) { var stack = new Stack(); for (var i = 0, len = string.length; i 逆波兰表达式 也叫后缀表达式，例如将 (a + b) x (c + d) 转为 ab + cd + x; 示例: [\"4\", \"13\", \"5\", \"/\", \"+\"] 想当于 4 + (13 / 5) = 6; var exp = [\"4\", \"13\", \"5\", \"/\", \"+\"]; var calcExp = function(exp) { var stack = new Stack(); for (var i = 0, len = exp.length; i = 0) { var val1 = stack.pop(); var val2 = stack.pop(); var result = parseInt(eval(val2 + item + val1)); stack.push(result.toString()); } else { stack.push(item); } } return stack.pop(); } console.log( calcExp(exp) ) 栈的算法题 实现一个 min 方法，返回栈的最小元素，且时间复杂度为 o(1); function MinStack() { var dataStack = new Stack(); var minStack = new Stack(); this.push = function(item) { if (minStack.isEmpty() || item 使用栈，完成中序表达式转后序表达式。 案例 编辑器撤销、恢复操作 powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/web/数据结构与算法/03-队列.html":{"url":"book/web/数据结构与算法/03-队列.html","title":"三、队列","keywords":"","body":"队列的概念 队列是一种特殊的线性表，特殊之处在于只允许在队列的头部删除元素，队列的尾部添加元素。 队列方法 enqueue，从队列尾部添加一个元素 dequeue，从队列头部删除一个元素 head，返回队列头部元素 size，返回队列大小 clear，清空队列 isEmpty，判断队列是否为空 tail，返回队列尾节点 实现方式 数组方式实现 function Queue() { var items = []; this.enqueue = function(item) { items.push(item); } this.dequeue = function() { return items.shift(); } this.head = function() { return items[0]; } this.size = function() { return items.length; } this.isEmpty = function() { return items.length === 0; } this.clear = function() { items.length = 0; } this.tail = function() { return items[items.length - 1]; } } 链表方式实现 应用 约瑟夫环（每三个删除一个） var arr = []; for (var i = 0; i 斐波那契数列（后一项是前两项之和） var fibonacci = function(n) { var queue = new Queue(); queue.enqueue(1); queue.enqueue(1); var index = 0; while (index 两个队列实现一个栈 杨辉三角 用两个栈实现一个队列 迷宫问题 数据结构之 - 树 powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/tool/git/":{"url":"book/tool/git/","title":"Git","keywords":"","body":"powered by GitbookFile Modify: 2024-10-30 18:45:45 "},"book/tool/git/01-git基本使用.html":{"url":"book/tool/git/01-git基本使用.html","title":"一、Git基本使用","keywords":"","body":"powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/tool/git/02-git进阶使用.html":{"url":"book/tool/git/02-git进阶使用.html","title":"二、Git进阶使用","keywords":"","body":"powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/tool/git/03-git工作流.html":{"url":"book/tool/git/03-git工作流.html","title":"三、Git工作流","keywords":"","body":"1. GitHub Flow 特点： master 分支永远是可以随时发布的 需求新增基于 master 分支，并创建一个有语义化的分支 定期推送本地分支到远端 合并到 master 分支之前要进行充分测试部署，之后必须提 PR PR 一旦经过 code review 无误即可合并到 master，立即进行部署发布 优点： 分支足够简单，适合持续发布场景 缺点： 多版本产品线不适用 2. Git Flow 特点： 通常包括五种类型的分支，并有明确定义 Master 分支：主干分支，也是正式发版分支，包含可以部署到生产环境的代码，通常只允许其他分支合入，不允许向 Master 分支直接提交代码 Develop 分支：开发分支，用来集成测试最新合入的开发成果，包含要发布到下一个 Release 的代码 Feature 分支：特性分支，通常从 Develop 分支拉出，每个新特性开发对应一个特性分支，用于开发人员提交代码进行自测，自测完成后，将 Feature 分支合到 Develop 分支，进入下一个 Release Release 分支：发布分支，发布新版本时候，基于 Develop 分支创建，发布完成后，合并到 Master 分支和 Develop 分支 Hot fix 分支：热修复分支，生产环境发现 Bug 时候基于 Master 创建的临时分支，问题验证后，合并到 Master 分支和 Develop 分支 优点： 分支任务功能明确 适合多个特性同时由多个开发人员独自开发各自的特性 可以同时处理上版本的发布以及下版本新特性的开发工作，上版本发布完成后合入 Master 与 Develop 分支 缺点： 合入成本较高 不适合修改频繁的项目 3. GitLab Flow 特点： 支持 GitFlow 的分支策略，也支持 GitHubFlow 的 Pull Request（在 GitLabFlow 中称为 Merge Request） 相比于 GitHubFlow，GitLabFlow 增加了对生产环境和与生产环境的管理 Master 分支：开发环境分支 Pre-Production 分支：预生产环境分支 Production 分支：生产环境分支 规定代码必须从上游向下游发展 Master --> Pre-Production --> Production 新功能或修复 Bug 时，特性分支代码测试无误时候，必须先合入 Master 分支，然后才能由 Master 分支向 Pre-Production 环境合入，最后由 Pre-Production 合入 Production GitLabFlow 中的 MergeRequest 是将一个分支合入到另一个分支的请求，通过 MergeRequest 可以对比合入分支和被合入分支的差异，也可以做代码的 Review。 设置 Master 保护分支，普通开发者不可以提交代码、合并代码 开发流程 开发阶段：Feature 分支 在 Master 分支上创建 Feature 分支开发功能，自测完成合并到 Master 分支 合并完成后删除 Feature 分支 测试阶段：Master 分支 部署 Master 分支到测试环境，出现 Bug，直接在 Master 分支修改 预发布阶段：Pre-Production 分支 Master 代码通过测试，基于 Master 创建 Pre-Prodution 分支 预发布阶段出现 Bug，在 Pre-Production 分支上创建一个修复 Bug 分支 修复 Bug 后，遵循上游优先，用 Master 合并 Bug 分支，部署测试环境验证 通过验证用 Pre-Production 合并 Bug 分支，在预生产环境验证，通过测试删除 Bug 分支，不通过重复上述步骤 发布阶段：Production 分支 预发布阶段代码通过测试，基于 Pre-Production 创建 Production 分支，部署到正式环境 正式环境出现 Bug，采用上游优先原则，与预发布阶段出现 Bug 一致解决步骤 版本发布： 在 Master 分支创建一个分支，命名比如 2-3-stable 版本分支出现 bug 还是遵循上游优先原则，从 Master 分支开始修复 Bug，通过测试执行 git cherry-pick commitId，合并到版本发布分支上 优点： 适合多环境发布、多特性同时开发 缺点： 合入成本高 powered by GitbookFile Modify: 2024-10-30 16:10:44 "},"book/tool/01-gitbook.html":{"url":"book/tool/01-gitbook.html","title":"GitBook","keywords":"","body":"一、安装与初始化 nvm切换nodejs版本v9.11.2 指定npm镜像源地址 npm config set registry https://registry.npmmirror.com 全局安装gitbook-cli（npm i gitbook-cli -g） 新建书文件夹并进入，执行 gitbook init 二、启动与打包 gitbook serve 启动 并在 http://localhost:4000 进行预览 gitbook build 打包生成 _book 文件夹就是打包的静态网页 powered by GitbookFile Modify: 2024-10-30 17:27:32 "},"book/tool/02-typora.html":{"url":"book/tool/02-typora.html","title":"Typora","keywords":"","body":"一、summary.md PART开头的标题为H2（固定的） 二、标题规范 一级标题H1：使用汉字加顿号，如：“一、二、三......” 二级标题H2：使用数字加顿号，如：“1、2、3......” 三级标题H3：使用数字加括号，如：“（1）（2）（3）......” 三、文档命名 0x-文档名.md powered by GitbookFile Modify: 2024-10-31 11:55:39 "}}